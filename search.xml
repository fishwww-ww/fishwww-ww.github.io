<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FastGPT实习：扫描二维码实现自动兑换积分</title>
      <link href="/2025/10/07/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%85%91%E6%8D%A2%E7%A7%AF%E5%88%86/"/>
      <url>/2025/10/07/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%85%91%E6%8D%A2%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="扫描二维码实现自动兑换积分的完整流程"><a href="#扫描二维码实现自动兑换积分的完整流程" class="headerlink" title="扫描二维码实现自动兑换积分的完整流程"></a>扫描二维码实现自动兑换积分的完整流程</h1><p>需求分析：在 FastGPT 平台实现用户扫描二维码自动兑换积分功能</p><p>用户扫描包含兑换码信息的二维码，自动跳转到门户网站登录页，登录成功后，自动兑换兑换码，增加账号积分</p><p>实现用户无需手动输入兑换码，提升用户体验</p><hr><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="二维码的本质"><a href="#二维码的本质" class="headerlink" title="二维码的本质"></a>二维码的本质</h3><p>二维码的本质是用二维图形存储二进制数据的信息载体</p><p>扫描一次二维码的本质是通过光学识别将图形转化为二进制数据，再解码出二维码中包含的数据，并执行</p><h3 id="二维码需要包含的信息"><a href="#二维码需要包含的信息" class="headerlink" title="二维码需要包含的信息"></a>二维码需要包含的信息</h3><ol><li>重定向地址</li><li>兑换码</li><li>兑换码是否被使用</li></ol><h3 id="实现登录后自动兑换的方案"><a href="#实现登录后自动兑换的方案" class="headerlink" title="实现登录后自动兑换的方案"></a>实现登录后自动兑换的方案</h3><h4 id="方案A：携带查询参数到登录页"><a href="#方案A：携带查询参数到登录页" class="headerlink" title="方案A：携带查询参数到登录页"></a>方案A：携带查询参数到登录页</h4><p>扫描二维码后, 会重定向到登录页, 同时url中会携带兑换码信息作为查询参数</p><p>登录接口会接收查询参数中的兑换码信息, 并在登录成功后再传递给兑换接口</p><p>兑换接口在收到兑换码信息后执行, 即可兑换积分</p><h4 id="方案B：使用本地存储"><a href="#方案B：使用本地存储" class="headerlink" title="方案B：使用本地存储"></a>方案B：使用本地存储</h4><p>扫码跳转登录页后，将兑换码存储在本地存储</p><p>登录后检测本地存储，符合条件则执行兑换API，并删除存储</p><hr><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>选择方案B</p><p>原因:</p><ol><li>登录接口有多种, 微信登录, 账密登录等等, 选择方案A的话每个接口都需要修改</li><li>修改底层登录接口这种行为, 入侵性太强, 不适合</li></ol><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>拼接门户网站URL和查询参数为一个重定向地址，用重定向地址生成二维码</li><li>跳转登录页后，检测URL查询参数包含兑换码，取出并存在本地存储</li><li>新写一个hook，挂载在layout文件中，实现登录成功后，从本地存储中取出兑换码，并执行兑换API，删除存储</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>登录成功，进入页面后自动执行，同时不破坏代码原有的逻辑结构，未来还可以拓展</li><li>符合React的钩子设计哲学(声明式而不是命令式)</li><li>实现登录与兑换解耦</li></ol><hr><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>用户扫描二维码后，整个兑换流程自动化完成，无需手动操作，大大提升了用户体验</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>用户体验流畅，无需手动输入兑换码</li><li>代码侵入性小，不破坏原有架构</li><li>可扩展性强，未来可以支持更多功能</li></ul><h3 id="后续优化方向"><a href="#后续优化方向" class="headerlink" title="后续优化方向"></a>后续优化方向</h3><ul><li>增加兑换码的有效期验证</li><li>支持批量兑换码处理</li><li>添加兑换记录和日志功能</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 实习经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastGPT实习：HTTP插件改造为HTTP工具集</title>
      <link href="/2025/10/05/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9AHTTP%E6%8F%92%E4%BB%B6%E6%94%B9%E9%80%A0%E4%B8%BAHTTP%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
      <url>/2025/10/05/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9AHTTP%E6%8F%92%E4%BB%B6%E6%94%B9%E9%80%A0%E4%B8%BAHTTP%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="FastGPT实习：HTTP插件改造为HTTP工具集"><a href="#FastGPT实习：HTTP插件改造为HTTP工具集" class="headerlink" title="FastGPT实习：HTTP插件改造为HTTP工具集"></a>FastGPT实习：HTTP插件改造为HTTP工具集</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>负责FastGPT开源项目中HTTP插件的重大架构升级，将原有的单一HTTP插件重构为灵活的HTTP工具集系统，提升了系统的可扩展性和用户体验。</p><hr><h2 id="核心工作内容"><a href="#核心工作内容" class="headerlink" title="核心工作内容"></a>核心工作内容</h2><h3 id="架构设计与重构"><a href="#架构设计与重构" class="headerlink" title="架构设计与重构"></a>架构设计与重构</h3><ul><li>将原有的单一HTTP插件（httpPlugin）重构为HTTP工具集（httpToolSet）</li><li>支持在一个工具集中管理多个HTTP工具</li></ul><h3 id="全栈开发"><a href="#全栈开发" class="headerlink" title="全栈开发"></a>全栈开发</h3><ul><li>独立完成前后端完整开发</li><li>包括React前端界面、Node.js后端API、数据库模型设计</li></ul><h3 id="工具集管理系统"><a href="#工具集管理系统" class="headerlink" title="工具集管理系统"></a>工具集管理系统</h3><ul><li>实现HTTP工具的CRUD操作</li><li>支持OpenAPI规范解析，自动生成工具配置</li></ul><h3 id="灵活配置能力"><a href="#灵活配置能力" class="headerlink" title="灵活配置能力"></a>灵活配置能力</h3><ul><li>支持自定义请求头、认证信息、超时设置等高级配置</li><li>满足企业级API集成需求</li></ul><h3 id="国际化支持"><a href="#国际化支持" class="headerlink" title="国际化支持"></a>国际化支持</h3><ul><li>完整的中英文国际化实现</li><li>提升产品国际化水平</li></ul><hr><h2 id="技术亮点"><a href="#技术亮点" class="headerlink" title="技术亮点"></a>技术亮点</h2><ol><li><strong>类型安全开发</strong>：采用TypeScript进行类型安全开发，确保代码质量</li><li><strong>动态表单生成</strong>：基于JSON Schema实现动态表单生成，提升用户配置体验</li><li><strong>状态管理优化</strong>：使用React Hook + Context模式进行状态管理，优化组件性能</li><li><strong>OpenAPI集成</strong>：实现OpenAPI规范自动解析，支持批量导入API工具</li><li><strong>可复用架构</strong>：设计可复用的工具集架构，为后续MCP工具集奠定基础</li></ol><hr><h2 id="技术实现细节"><a href="#技术实现细节" class="headerlink" title="技术实现细节"></a>技术实现细节</h2><h3 id="前端架构"><a href="#前端架构" class="headerlink" title="前端架构"></a>前端架构</h3><ul><li>使用React + TypeScript构建现代化前端界面</li><li>基于Chakra UI实现响应式设计，支持PC和移动端</li><li>采用Context + useContextSelector优化组件渲染性能</li><li>实现动态表单系统，支持JSON Schema驱动的配置界面</li></ul><h3 id="后端架构"><a href="#后端架构" class="headerlink" title="后端架构"></a>后端架构</h3><ul><li>设计RESTful API接口，支持工具集的完整CRUD操作</li><li>实现OpenAPI规范解析器，自动生成HTTP工具配置</li><li>集成MongoDB进行数据持久化，支持事务操作</li><li>添加完整的权限控制和团队隔离机制</li></ul><h3 id="核心功能模块"><a href="#核心功能模块" class="headerlink" title="核心功能模块"></a>核心功能模块</h3><ul><li>HTTP工具集创建与管理：<code>/api/core/app/httpTools/create</code></li><li>OpenAPI规范解析与工具生成</li><li>动态请求头和认证配置</li><li>工具执行引擎与结果处理</li></ul><h3 id="代码质量保障"><a href="#代码质量保障" class="headerlink" title="代码质量保障"></a>代码质量保障</h3><ul><li>完整的TypeScript类型定义</li><li>统一的错误处理机制</li><li>国际化支持（i18n）</li><li>组件化和可复用设计</li></ul><hr><h2 id="项目影响"><a href="#项目影响" class="headerlink" title="项目影响"></a>项目影响</h2><h3 id="管理效率提升"><a href="#管理效率提升" class="headerlink" title="管理效率提升"></a>管理效率提升</h3><ul><li>提升了HTTP工具的管理效率</li><li>用户可在单个工具集中管理多个相关API</li></ul><h3 id="系统可扩展性"><a href="#系统可扩展性" class="headerlink" title="系统可扩展性"></a>系统可扩展性</h3><ul><li>增强了系统的可扩展性</li><li>为企业级API集成提供了更强大的支持</li></ul><h3 id="用户体验优化"><a href="#用户体验优化" class="headerlink" title="用户体验优化"></a>用户体验优化</h3><ul><li>优化了用户体验</li><li>简化了HTTP工具的创建和配置流程</li></ul><hr><h2 id="量化成果"><a href="#量化成果" class="headerlink" title="量化成果"></a>量化成果</h2><ul><li><strong>代码贡献</strong>：新增约2000+行高质量TypeScript代码</li><li><strong>功能覆盖</strong>：支持GET&#x2F;POST&#x2F;PUT&#x2F;DELETE等全HTTP方法</li><li><strong>配置灵活性</strong>：支持自定义请求头、认证、超时等10+配置项</li><li><strong>用户体验</strong>：将HTTP工具创建流程从多步骤简化为一站式配置</li></ul><hr><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p><strong>前端技术</strong>：TypeScript, React, Chakra UI, JSON Schema</p><p><strong>后端技术</strong>：Node.js, MongoDB, RESTful API</p><p><strong>开发工具</strong>：OpenAPI, 国际化, 组件化设计, 性能优化</p><p>这个项目展现了在全栈开发、架构设计、用户体验优化等多个方面的能力，特别是在开源项目中的贡献和对复杂业务场景的技术解决方案设计能力。</p><hr><h2 id="简历重点"><a href="#简历重点" class="headerlink" title="简历重点"></a>简历重点</h2><ul><li>HTTP工具集的增删改查基本方法<br>  设计restful api</li><li>openapi自动解析<br>  外部包 + 手动处理</li><li>自定义请求头和鉴权配置<br>  前端动态配置 + 后端存储 + 运行使用</li><li>前端还原figma设计稿</li><li>工具执行<br>  封装HTTP请求类</li><li>节点相关<br>  存储节点: 保存ui等信息, 便于渲染<br>  运行时节点: 只保留运行时的相关配置, 加快运行速度</li><li>节点业务逻辑(太复杂了)<br>  工具调用请求<br>  ↓<br>  dispatchRunTools (Agent节点)<br>  ↓<br>  LLM工具选择 + 参数解析<br>  ↓<br>  runToolCall (工具调用循环)<br>  ↓<br>  dispatchRunTool (具体工具执行)<br>  ↓<br>  工具类型分发 (System&#x2F;HTTP&#x2F;MCP)<br>  ↓<br>  结果处理 + 格式化<br>  ↓<br>  返回给Agent继续对话</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 实习经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastGPT实习：生产者-消费者模式实现企微流式响应</title>
      <link href="/2025/09/21/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%BC%81%E5%BE%AE%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94/"/>
      <url>/2025/09/21/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%BC%81%E5%BE%AE%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="从企业微信流式响应中学习生产者-消费者模式"><a href="#从企业微信流式响应中学习生产者-消费者模式" class="headerlink" title="从企业微信流式响应中学习生产者-消费者模式"></a>从企业微信流式响应中学习生产者-消费者模式</h1><p>需求分析：在 FastGPT 平台，将工作流的发布渠道与企业微信智能机器人对接</p><p>实现企业微信回调 FastGPT 的地址，FastGPT 将工作流处理好的 AI 回复返回给企微</p><p>实现企微智能机器人能够使用 FastGPT 平台的功能</p><hr><h2 id="企业微信对接文档-流式响应的架构"><a href="#企业微信对接文档-流式响应的架构" class="headerlink" title="企业微信对接文档-流式响应的架构"></a>企业微信对接文档-流式响应的架构</h2><p>企微会给回调 URL(即自己配置的后台程序)发送两种类型的请求</p><p>第一种是消息推送, 只会在第一次向后台程序发送请求时发送</p><p>第二种是轮询请求。即当企微接收到消息推送请求的响应后,开始发送轮询请求</p><p>具体文档可参考 <a href="https://developer.work.weixin.qq.com/document/path/100719">企业微信智能机器人文档</a></p><hr><h2 id="实现难点"><a href="#实现难点" class="headerlink" title="实现难点"></a>实现难点</h2><ol><li>为什么企业微信要发送轮询请求？消息推送请求和轮询请求的本质区别是什么？需要为两种请求写不一样的逻辑处理吗？</li><li>等待 AI 输出全部结果，再返回给企微，耗时太长，如何优化</li><li>HTTP 请求是无状态的, 后台程序每收到一次请求, 都不知道上一次请求响应了什么数据, 从而无法实现回复内容的追加</li><li>如果每接收一次请求, 就调用一次 AI 输出回答. 由于轮询的频率很快, 一次 AI 回答还没输出完, 就要又一次调用 AI 输出. 最后会产生“轮询次数 + 1”倍的 AI 回复</li><li>AI 回复结束, 就要停止企微的轮询请求(发送特定格式的数据包), 那么要给后台程序怎样的逻辑, 才能实现 AI 回复结束,就向企微发送”结束数据包”</li></ol><hr><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="方案一-一次请求对应一次完整回复"><a href="#方案一-一次请求对应一次完整回复" class="headerlink" title="方案一 一次请求对应一次完整回复"></a>方案一 一次请求对应一次完整回复</h3><p>企微发送一个请求，程序接收后，会调用 AI 输出回答，AI 回复结束后，返回给企微一个响应</p><h4 id="具体效果"><a href="#具体效果" class="headerlink" title="具体效果"></a>具体效果</h4><p>首先是等待 AI 输出完成的时间太长，用户体验不佳</p><p>其次每接收一次请求都调用一次 AI，因为有轮询请求，所以会产生非常多次 AI 回复</p><p>而企微会渲染最后一次接收的回复，那么前面的回复就浪费了性能</p><h3 id="方案二-流式回复"><a href="#方案二-流式回复" class="headerlink" title="方案二 流式回复"></a>方案二 流式回复</h3><p>使用异步迭代器，异步流式处理数据</p><ol><li>异步可迭代对象生成一个异步迭代器</li><li>异步迭代器自动调用 next()方法, 通过异步请求获取 ai 回复</li><li>判断迭代结果的 done 值是否为 true, 是则停止循环, 不是则重复第二步请求数据</li></ol><h4 id="具体效果-1"><a href="#具体效果-1" class="headerlink" title="具体效果"></a>具体效果</h4><p>通过异步获取数据, 使得 ai 回复数据传输到 FastGPT 平台是”实时”的, 解决了等待 ai 回复时间过久的问题</p><p>但是没有解决从 FastGPT 到企微, 一段一段的流式数据如何传输的问题</p><h3 id="方案-n-生产者-消费者设计模式"><a href="#方案-n-生产者-消费者设计模式" class="headerlink" title="方案 n 生产者 - 消费者设计模式"></a>方案 n 生产者 - 消费者设计模式</h3><p>生产者: 程序接收消息推送请求，负责将数据写入 redis</p><p>消费者: 程序接受轮询请求，负责从 redis 中取出数据</p><p>缓存层: redis</p><h4 id="具体效果-2"><a href="#具体效果-2" class="headerlink" title="具体效果"></a>具体效果</h4><p>用户向企微发送消息后, 企微会先向后台程序发送一次消息推送请求</p><p>后台程序接收推送并按照企微的要求响应，响应后程序不会立即停止</p><p>而是等待 AI 不断输出新的回复，并不断将新的回复写入 redis 当中</p><p>写入是以追加的形式写入，即每次携带的回复都是上一次携带回复数据的追加值(累加值)</p><p>直到 AI 输出完成，这一次响应才彻底结束</p><p>在企微这边，当接收到消息推送请求的响应后, 就开始发送轮询请求(发送时间间隔 &lt; 1s )</p><p>后台程序接收到一次轮询请求后，就从 redis 中取出数据,并返回给企微</p><p>由于程序会不断将 AI 的输出结果存入 redis，而 AI 的输出是流式的</p><p>所以每一次从 redis 中取出的数据是越来越多，逐渐完善的</p><p>从而实现返回给企微的数据是类似 AI 输出的流式效果</p><p>当后台程序发现 AI 已经回复完成后，会在文本末尾加上“[DONE]”，表示回复结束</p><p>此时程序检测到文本末尾的内容，就会向企微发送一个特殊格式的数据包，标志着回复结束</p><p>企微接收到结束数据包，便不再发送请求，轮询结束，一次 AI 对话完成</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><h4 id="后续优化方向"><a href="#后续优化方向" class="headerlink" title="后续优化方向"></a>后续优化方向</h4><p>缓存层使用消息队列，能更加方便控制缓存的粒度</p><p>实时通信方式采用 WebSocket，而不是 HTTP 轮询</p><p>HTTP 轮询每一次请求都要重新连接，开销大，而 WebSocket 只需一次连接</p><p>HTTP 轮询的服务端只能被动回复客户端，而 WebSocket 的服务端能够主动给通信</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机（SVM）初见</title>
      <link href="/2025/05/09/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%EF%BC%88SVM%EF%BC%89%E5%88%9D%E8%A7%81/"/>
      <url>/2025/05/09/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%EF%BC%88SVM%EF%BC%89%E5%88%9D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h1 id="SVM-学习"><a href="#SVM-学习" class="headerlink" title="SVM 学习"></a>SVM 学习</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>SVM分为：<ul><li><strong>SVC</strong>（分类任务）</li><li><strong>SVR</strong>（回归任务），股票分析主要用SVR</li></ul></li><li><strong>超平面</strong>：k-1维的最佳分类标准</li><li><strong>支持向量</strong>：离超平面最近的点</li><li><strong>支持向量机</strong>：找到支持向量，构建超平面</li><li><strong>核函数</strong>：将低维空间映射到高维空间，使得数据线性可分</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>以 <code>get_train_model</code> 函数为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_train_model</span>(<span class="params">dataset</span>):</span><br><span class="line">    <span class="comment"># 设置训练阶树</span></span><br><span class="line">    DEGREE_POLY = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进行因子筛选</span></span><br><span class="line">    selected_factors = get_ic_with_sharpe(dataset)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进行训练集和测试集提取</span></span><br><span class="line">    X = dataset[selected_factors].values</span><br><span class="line">    y = dataset[<span class="string">&#x27;sharpe&#x27;</span>].values</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># SVM 的 Pipeline</span></span><br><span class="line">    svm_pipe = Pipeline([</span><br><span class="line">        (<span class="string">&#x27;sc&#x27;</span>, StandardScaler()), </span><br><span class="line">        (<span class="string">&#x27;poly&#x27;</span>, PolynomialFeatures(degree=DEGREE_POLY)),</span><br><span class="line">        (<span class="string">&#x27;svm&#x27;</span>, SVR())</span><br><span class="line">    ])  <span class="comment"># 添加多项式特征</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置 SVM 的参数的取值范围</span></span><br><span class="line">    svm_params = &#123;</span><br><span class="line">        <span class="string">&#x27;svm__C&#x27;</span>: np.logspace(-<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>),</span><br><span class="line">        <span class="string">&#x27;svm__degree&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        <span class="string">&#x27;svm__kernel&#x27;</span>: [<span class="string">&#x27;poly&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置 SVM 的 GridSearchCV 实例</span></span><br><span class="line">    svm_gs = GridSearchCV(svm_pipe, svm_params, scoring=<span class="string">&#x27;r2&#x27;</span>, n_jobs=-<span class="number">1</span>, cv=<span class="built_in">min</span>(<span class="number">5</span>, <span class="built_in">len</span>(X_train) - <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练 SVM 模型</span></span><br><span class="line">    svm_gs.fit(X_train, y_train)</span><br><span class="line">    best_svm_pipe = svm_gs.best_estimator_</span><br><span class="line">    best_svm_pipe.fit(X_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(best_svm_pipe)</span><br><span class="line">    <span class="keyword">return</span> best_svm_pipe</span><br></pre></td></tr></table></figure><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><h3 id="1-数据读取和预处理"><a href="#1-数据读取和预处理" class="headerlink" title="1. 数据读取和预处理"></a>1. 数据读取和预处理</h3><ol><li>设置阶数（因为用的核函数是多项式核）</li><li>筛选因子</li><li>数据集划分，分为训练集和测试集</li></ol><h3 id="2-模型构建（使用-Pipeline-）"><a href="#2-模型构建（使用-Pipeline-）" class="headerlink" title="2. 模型构建（使用 Pipeline ）"></a>2. 模型构建（使用 Pipeline ）</h3><ol><li>标准化：统一数据尺度，提升模型性能，避免某些特征因数值范围过大而对模型产生不成比例的影响</li><li>多项式特征转换：数据升维</li><li>SVM回归器（SVR）</li></ol><h3 id="3-参数优化"><a href="#3-参数优化" class="headerlink" title="3. 参数优化"></a>3. 参数优化</h3><ol><li>参数网格搜索：排列组合每种参数组合<ul><li>C值：惩罚项，越大，对错误分类的惩罚越重，模型会尽量正确分类所有训练样本，可能导致过拟合</li><li>多项式阶数：阶数越高，模型越复杂，越容易过拟合</li><li>核函数：将数据映射到更高维空间，使线性不可分的问题变得线性可分</li></ul></li><li>交叉验证：评估每组参数性能，可防止过拟合，（做法：将训练集分成k份···）</li></ol><h3 id="4-训练模型"><a href="#4-训练模型" class="headerlink" title="4. 训练模型"></a>4. 训练模型</h3><p>使用最佳参数训练，返回训练最佳模型</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人月神话》读书笔记</title>
      <link href="/2025/04/17/%E3%80%8A%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/04/17/%E3%80%8A%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="《人月神话》读书笔记"><a href="#《人月神话》读书笔记" class="headerlink" title="《人月神话》读书笔记"></a>《人月神话》读书笔记</h1><p>2025.4.13 - 2025.4.17，笔者拜读了软件工程领域的名作《人月神话》，在此写下读书笔记与心得。</p><hr><h2 id="1-书籍介绍"><a href="#1-书籍介绍" class="headerlink" title="1. 书籍介绍"></a>1. 书籍介绍</h2><p>《人月神话》的行文以比喻见长，将软件工程中的各种问题以比喻的形式呈现</p><p>同时，本书表面上是讲软件工程，真正的内核是软件工程背后的社会学原理</p><p>遗憾的是，笔者才学疏浅，无法全部理解书中的各种概念，加之年代久远和翻译的误差，很多说法与如今有所出入</p><p>比如说系统设计与开发，在书中应该是指的是软件项目的架构的设计与实现</p><p>而在如今的语境中，指的是操作系统的设计与开发</p><p>尽管有所偏差，但笔者仍然想写下对书中经典比喻的分析</p><hr><h2 id="2-内核分析"><a href="#2-内核分析" class="headerlink" title="2. 内核分析"></a>2. 内核分析</h2><ul><li><p>焦油坑：在大型的软件开发中，实际进度会被各种问题耽搁<br>这些问题可以分为项目本身的代码问题和项目外的管理问题<br>从项目本身来看，如果一个项目前期的技术选型，代码规范，开发流程等没有事前安排好<br>那么随着项目的开发，这些问题会逐渐暴露，最终成为拖延进度的焦油坑；<br>从项目外来看，一个开发团队的组织与管理也会影响到项目的进度，一个好的团队可以参考后面的“外科手术队伍”这个比喻。<br>在笔者目前的认知中，最广为人知的焦油坑就是Windows操作系统。win系统从面世至今，经历了大大小小无数次内核改动。<br>可以说对于微软系统维护人员来说，Windows无疑是一座屎山，也是整个公司的焦油坑</p></li><li><p>人月神话：人月（Man-Month）指的是一名程序员一个月全职的工作量<br>而人月神话则是说在项目开发中不能简单的用人数换取时间进度，因而将这个说法称为人月神话<br>这里，笔者想讨论为什么不能用“人”来换“月”。<br>在一个软件项目中，如果一个项目的进度落后于规划，项目负责人想的第一件事很可能是增加人手<br>但软件行业不同于其它行业，增加的新人需要花时间熟悉项目的代码和开发流程<br>需要老成员来指导培训，甚至可能要处理新人开发不规范带来的问题。这样一来，项目的进度不但没有加快，反而被拖慢了。<br>但是在现实中，项目的进度遇到问题，负责人要么无休止的招新人，要么让老成员陷入加班的无底洞<br>这无疑是现代软件工程的可悲之处</p></li><li><p>外科手术队伍：不同于扁平化的团队模式，外科手术队伍指团队有一个核心开发（书中称之为首席程序员），也可以理解为CTO<br>整个团队的人员配置都是围绕这个核心开发展开的，比如要为核心开发配备一个副手，几个文员等等，再往下的就是普通程序员<br>这样的人员配置可能会遇到一些问题，这将在下面的“贵族专制”中提到，在现代公司的软件开发团队中，似乎与书中的外科手术队伍有所不同<br>这里由于笔者经验不足，无法获得更高层面的认知，就将此话题按下不表<br>不过在小型初创团队中，扁平化的管理方案似乎更能够提高效率</p></li><li><p>贵族专制和民主政治：贵族专制指的就是在外科手术团队的配置下，可能整个项目的走向都被首席程序员所决定<br>没有充分发挥下面普通程序员的主观能动性，下面的人也很难为团队建言献策<br>在这种情况下，民主政治的必要性就体现了出来，它使得所有人都能为项目提供建议，改善方向<br>但是在现代公司体系下，一个互联网公司&#x2F;一个软件开发团队，究竟能发挥多少民主政治，这要打一个大大的问好了</p></li><li><p>巴比伦塔的失败：在神话故事中，神让人们语言不通，通天塔的建造就此失败<br>在软件开发中，巴比伦塔的失败指的是团队成员之间的沟通不畅<br>那如何提高沟通次数效率呢？频繁的开会未必是个好主意<br>更需要的或许是精简团队人员，让整个团队保持同频</p></li><li><p>银弹：银弹（Silver Bullet）是由国外的人狼民间传说翻译而来<br>在故事中，人狼是个能从熟悉的面孔变成可怕怪物的东西，为了对付人狼，要寻找能消灭它们的银弹<br>银弹的本质就是解决某一个问题的方法，在中文语境下，可以理解为“灵丹妙药”、“尚方宝剑”或是“万精油”，但是不能等同<br>任何一个软件项目中几乎都存在人狼，比如对开发人员的技术高估，对项目的复杂度低估，预算的不充足等等<br>在这种情况下，开发人员迫切的渴求银弹，能解决这些问题，但是现实就是“没有银弹”</p></li><li><p>没有银弹：在书中，作者断言软件行业至少十年内不可能出现一种技术或是方法能大幅提升生产效率，简称“没有银弹”<br>这一说法首先要从软件的本质说起，首先软件本身就存在复杂度，可以分为本质复杂度和附加复杂度<br>本质复杂度指的是把现实世界的事物抽象成软件、编程语言的复杂程度<br>附加复杂度是指方法、工具和编程语言的落后等等带来的复杂度<br>从软件工程发展至今，从汇编，到c语言，再到面对对象和各种框架<br>人们用诸如oop、设计模式、敏捷开发等方法来降低复杂度<br>但究其根本，降低的都是附件复杂度，软件的本质复杂度始终没有改变，银弹始终没有找到<br>显然现代软件工程面临的问题是如何找到降低本质复杂度的方法<br>但最有可能的结果是，世界上根本不存在这样的方法，现实本身就是没有银弹</p></li></ul><hr><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>软件工程背后的社会学原理着实丰富，以目前笔者的经历与见识，可以说是管中窥豹</p><p>希望未来的某一天，当笔者能真正在一个软件项目团队独当一面时，能回想起人月神话中的道理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go爬虫学习</title>
      <link href="/2025/04/12/go%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/04/12/go%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="golang爬虫学习"><a href="#golang爬虫学习" class="headerlink" title="golang爬虫学习"></a>golang爬虫学习</h1><p>目的是学习一下爬虫的流程，顺便熟悉一下go的语法和使用</p><p>代码仓库见<a href="https://github.com/fishwww-ww/go-spider-mundo">我的github仓库</a></p><hr><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>本项目爬取的是<a href="https://mundo.trancecho.top/">mundo</a>中的组队信息，从而快速了解组队的概况，以便进一步筛选适合且人数未满的队伍</p><p>使用的工具：</p><ul><li>golang原生http库等网络请求、解析相关的库</li><li>gorm</li><li>docker</li></ul><hr><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><h3 id="1-分析网页"><a href="#1-分析网页" class="headerlink" title="1. 分析网页"></a>1. 分析网页</h3><p>打开<a href="https://mundo.trancecho.top/teamup">mundo组队</a>页面,F12打开开发者工具，找到网络栏</p><p>在document类型的请求中找到名为teamup的请求,查看它的响应,</p><p>发现里面没有数据,说明这些信息是通过api请求得到的,无法在DOM中获取</p><p>再筛选xhr类型,找到 allteam?service&#x3D;mundo ,正是所需要的响应</p><p>接下来通过伪造api请求,来获取它的响应,从而实现数据爬取</p><h3 id="2-实现请求"><a href="#2-实现请求" class="headerlink" title="2. 实现请求"></a>2. 实现请求</h3><p>将响应的json转换为go的结构体<br>可以直接复制json数据,交给ai处理,也可以用爬虫工具处理<br>得到响应结构体</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="type">int</span>    <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">    Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">    Data    Data   <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用go的http库,创建一个客户端,并将方法和url填入,构造一个请求</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://qgdoywhgtdnh.sealosbja.site/timerme/api/allteam?service=mundo&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>填入一些请求头,大型网站都有反爬机制,请求头越详细越好,这里只填入部分信息</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">req.Header.Set(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36 Edg/135.0.0.0&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json, text/plain, */*&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip, deflate, br, zstd&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行请求,并获取响应,别忘了最后关闭请求</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure><p>读取响应,并反序列化,便于后期操作数据</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">err = json.Unmarshal(body, &amp;response)</span><br></pre></td></tr></table></figure><h3 id="3-存入数据库"><a href="#3-存入数据库" class="headerlink" title="3. 存入数据库"></a>3. 存入数据库</h3><p>我是在docker中下的mysql,启动后新建一个schema,这个schema要和代码中的DBNAME对应上</p><p>直接用gorm框架来连接mysql</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DB, err = gorm.Open(mysql.Open(path), &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure><p>然后用AutoMigrate方法自动建表</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = DB.AutoMigrate(&amp;Content&#123;&#125;)</span><br></pre></td></tr></table></figure><p>最后回到处理响应的部分,将数据插入数据库中</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result := DB.Create(&amp;response.Data.Team.Content)</span><br></pre></td></tr></table></figure><hr><h2 id="项目收获"><a href="#项目收获" class="headerlink" title="项目收获"></a>项目收获</h2><ul><li>学会了分析网页和实现爬虫程序的流程</li><li>熟悉了go,docker和数据库连接,把请求,响应,解析,存储等流程串联起来</li></ul><h2 id="后续学习"><a href="#后续学习" class="headerlink" title="后续学习"></a>后续学习</h2><ul><li>学习go的并发编程,提高爬虫效率</li><li>学习docker的目录挂载机制,如何将数据挂载在宿主机中,实现数据的持久化</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>myFirstBlog</title>
      <link href="/2024/06/11/myFirstBlog/"/>
      <url>/2024/06/11/myFirstBlog/</url>
      
        <content type="html"><![CDATA[<h1 id="标题一"><a href="#标题一" class="headerlink" title="标题一"></a>标题一</h1><p>内容一二三四五<br><a href="https://www.baidu.com/">百度</a></p><hr><h2 id="标题二"><a href="#标题二" class="headerlink" title="标题二"></a>标题二</h2><p><a href="http://www.bing.com/">www.bing.com</a></p><hr><h3 id="标题三"><a href="#标题三" class="headerlink" title="标题三"></a>标题三</h3><p>markdown语法</p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
