<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>服务器：Ollama本地部署大模型与公网服务器内网穿透</title>
      <link href="/2025/12/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9AOllama%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2025/12/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9AOllama%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Windows 机使用 <code>ollama</code> 本地部署 <code>qwen</code>，云服务器使用内网穿透与 Windows 机连接，实现其他机器（如 Mac）远程调用 Windows 运行的大模型服务。</p><h2 id="ollama-本地部署大模型"><a href="#ollama-本地部署大模型" class="headerlink" title="ollama 本地部署大模型"></a>ollama 本地部署大模型</h2><h3 id="安装与验证"><a href="#安装与验证" class="headerlink" title="安装与验证"></a>安装与验证</h3><ol><li>在 <a href="https://ollama.com/">ollama 官网</a> 下载对应操作系统版本</li><li>本地 <code>cmd</code> 输入 <code>ollama</code>，检测是否安装成功</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama</span><br></pre></td></tr></table></figure><h3 id="拉取与运行模型"><a href="#拉取与运行模型" class="headerlink" title="拉取与运行模型"></a>拉取与运行模型</h3><ol start="3"><li>拉取模型到本地，以 <code>qwen2.5:3b-instruct</code> 为例：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama pull qwen2.5:3b-instruct</span><br></pre></td></tr></table></figure><ol start="4"><li>拉取完成后，运行模型，检查模型是否正常输出，检查本地 GPU 是否有资源占用（防止模型使用 CPU 运行，降低运行效率）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run qwen2.5:3b-instruct</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol start="5"><li>直接使用命令行交互式测试，或使用 <code>curl</code> 命令调用 API 测试：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:11434/api/generate -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;model&quot;: &quot;qwen2.5:3b-instruct&quot;,</span></span><br><span class="line"><span class="string">  &quot;prompt&quot;: &quot;你好&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>本质就是以有公网 IP 的服务器作为跳板机，使得访问服务器的服务，转发到本地 Windows 机的服务。</p><p>这里使用 <code>frp</code> 作为内网穿透工具，来高效轻量搭建反向代理隧道。</p><p><strong>下载地址</strong>：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><h3 id="架构流程"><a href="#架构流程" class="headerlink" title="架构流程"></a>架构流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│  公网用户    │ (Mac/其他设备)</span><br><span class="line">│  (Client)   │</span><br><span class="line">└──────┬──────┘</span><br><span class="line">       │ HTTP请求</span><br><span class="line">       │ &lt;server-ip&gt;:11434</span><br><span class="line">       ▼</span><br><span class="line">┌─────────────────────────┐</span><br><span class="line">│   公网服务器 (frps)      │</span><br><span class="line">│   - 监听端口: 11434      │</span><br><span class="line">│   - 控制端口: 7000       │</span><br><span class="line">└──────┬──────────────────┘</span><br><span class="line">       │ 转发请求</span><br><span class="line">       │ (TCP隧道)</span><br><span class="line">       ▼</span><br><span class="line">┌─────────────────────────┐</span><br><span class="line">│  Windows 机 (frpc)       │</span><br><span class="line">│   - 连接服务器: 7000     │</span><br><span class="line">│   - 本地服务: 11434      │</span><br><span class="line">└──────┬──────────────────┘</span><br><span class="line">       │ 访问本地服务</span><br><span class="line">       ▼</span><br><span class="line">┌─────────────────────────┐</span><br><span class="line">│   本地 Ollama 服务       │</span><br><span class="line">│   - 端口: 11434          │</span><br><span class="line">│   - 模型: qwen2.5:3b     │</span><br><span class="line">└─────────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>数据流向</strong>：<code>公网用户 → 公网服务器(frps) → Windows(frpc) → 本地 ollama</code></p><h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><h4 id="1-下载与解压"><a href="#1-下载与解压" class="headerlink" title="1. 下载与解压"></a>1. 下载与解压</h4><p>从下载地址下载对应版本，如 <code>frp_0.65.0_linux_amd64.tar.gz</code> 版本，并解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载对应版本的压缩包</span></span><br><span class="line">curl -fsLO https://github.com/fatedier/frp/releases/download/v0.65.0/frp_0.65.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压压缩包</span></span><br><span class="line">tar -xzf frp_0.65.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><h4 id="2-配置参数"><a href="#2-配置参数" class="headerlink" title="2. 配置参数"></a>2. 配置参数</h4><p>在 <code>frps.toml</code> 中配置参数：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bindPort</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">bindAddr</span> = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">auth.method</span> = <span class="string">&quot;token&quot;</span></span><br><span class="line"><span class="attr">auth.token</span> = <span class="string">&quot;root1234&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">transport.tls.force</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[allowPorts]]</span></span><br><span class="line"><span class="attr">single</span> = <span class="number">11434</span></span><br></pre></td></tr></table></figure><h4 id="3-启动-frps"><a href="#3-启动-frps" class="headerlink" title="3. 启动 frps"></a>3. 启动 frps</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c frps.toml</span><br></pre></td></tr></table></figure><h3 id="Windows-本机配置"><a href="#Windows-本机配置" class="headerlink" title="Windows 本机配置"></a>Windows 本机配置</h3><h4 id="1-下载与解压-1"><a href="#1-下载与解压-1" class="headerlink" title="1. 下载与解压"></a>1. 下载与解压</h4><p>从下载地址下载对应版本，如 <code>frp_0.65.0_windows_amd64.zip</code> 版本，并解压。</p><h4 id="2-配置参数-1"><a href="#2-配置参数-1" class="headerlink" title="2. 配置参数"></a>2. 配置参数</h4><p>在 <code>frpc.toml</code> 中配置参数：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">serverAddr</span> = &lt;server ip&gt;</span><br><span class="line"><span class="attr">serverPort</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">auth.token</span> = <span class="string">&quot;root1234&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;ollama run qwen2.5:3b-instruct&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;tcp&quot;</span></span><br><span class="line"><span class="attr">localIP</span> = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">11434</span></span><br><span class="line"><span class="attr">remotePort</span> = <span class="number">11434</span></span><br></pre></td></tr></table></figure><h4 id="3-开放-Ollama-端口"><a href="#3-开放-Ollama-端口" class="headerlink" title="3. 开放 Ollama 端口"></a>3. 开放 Ollama 端口</h4><p>在 Windows 中配置环境变量 <code>OLLAMA_HOST=0.0.0.0:11434</code>，并<strong>重启电脑</strong>使环境变量生效（一定要重启电脑）。</p><blockquote><p><strong>注意</strong>：不配置这个环境变量的话，<code>ollama</code> 的服务默认运行在 <code>127.0.0.1:11434</code>，不对外暴露服务。</p></blockquote><h4 id="4-启动-frpc"><a href="#4-启动-frpc" class="headerlink" title="4. 启动 frpc"></a>4. 启动 frpc</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\frpc -c frpc.toml</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：Windows 与 Linux 命令的差异，Windows 使用 <code>.\frpc</code>，Linux 使用 <code>./frps</code>。</p></blockquote><h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h4><p>调用公网 IP 的端口，测试内网穿透到本机大模型服务是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl http://&lt;server ip&gt;:11434/api/generate -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;model&quot;: &quot;qwen2.5:3b-instruct&quot;,</span></span><br><span class="line"><span class="string">  &quot;prompt&quot;: &quot;你好&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="编写脚本快速启动和关闭"><a href="#编写脚本快速启动和关闭" class="headerlink" title="编写脚本快速启动和关闭"></a>编写脚本快速启动和关闭</h3><h4 id="服务端脚本"><a href="#服务端脚本" class="headerlink" title="服务端脚本"></a>服务端脚本</h4><p><strong>特性</strong>：</p><ul><li>使用 <code>nohup</code> 命令运行，确保关闭 SSH 会话后进程继续运行</li><li>启动前会自动检查是否已有进程在运行</li></ul><p>新建启动文件 <code>start_frps.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FRP 服务端启动脚本</span></span><br><span class="line"><span class="comment"># 使用 nohup 确保关闭会话后进程继续运行</span></span><br><span class="line"></span><br><span class="line">SCRIPT_DIR=<span class="string">&quot;<span class="subst">$(cd <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$&#123;BASH_SOURCE[0]&#125;</span>&quot;</span>)</span>&quot;</span> &amp;&amp; pwd)</span>&quot;</span></span><br><span class="line">FRPS_BIN=<span class="string">&quot;<span class="variable">$SCRIPT_DIR</span>/frps&quot;</span></span><br><span class="line">FRPS_CONFIG=<span class="string">&quot;<span class="variable">$SCRIPT_DIR</span>/frps.toml&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 frps 可执行文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">&quot;<span class="variable">$FRPS_BIN</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;错误: 找不到 frps 可执行文件: <span class="variable">$FRPS_BIN</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查配置文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">&quot;<span class="variable">$FRPS_CONFIG</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;错误: 找不到配置文件: <span class="variable">$FRPS_CONFIG</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查进程是否在运行（精确匹配进程名）</span></span><br><span class="line"><span class="keyword">if</span> pgrep -x <span class="string">&quot;frps&quot;</span> &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;警告: 检测到 frps 进程正在运行，请先使用 stop_frps.sh 停止&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 frps</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;正在启动 frps...&quot;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$SCRIPT_DIR</span>&quot;</span></span><br><span class="line"><span class="built_in">nohup</span> <span class="string">&quot;<span class="variable">$FRPS_BIN</span>&quot;</span> -c <span class="string">&quot;<span class="variable">$FRPS_CONFIG</span>&quot;</span> &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">FRPS_PID=$!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待一下，检查进程是否成功启动</span></span><br><span class="line"><span class="built_in">sleep</span> 2</span><br><span class="line"><span class="keyword">if</span> ps -p <span class="string">&quot;<span class="variable">$FRPS_PID</span>&quot;</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;frps 启动成功!&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;PID: <span class="variable">$FRPS_PID</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;配置文件: <span class="variable">$FRPS_CONFIG</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;提示: 使用 &#x27;./stop_frps.sh&#x27; 停止服务&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;错误: frps 启动失败&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>新建关闭文件 <code>stop_frps.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FRP 服务端停止脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 frps 是否在运行（精确匹配进程名）</span></span><br><span class="line"><span class="keyword">if</span> pgrep -x <span class="string">&quot;frps&quot;</span> &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;正在停止 frps...&quot;</span></span><br><span class="line">    <span class="comment"># 先尝试正常终止</span></span><br><span class="line">    pkill -x <span class="string">&quot;frps&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待进程结束</span></span><br><span class="line">    <span class="built_in">sleep</span> 2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果进程仍在运行，强制终止</span></span><br><span class="line">    <span class="keyword">if</span> pgrep -x <span class="string">&quot;frps&quot;</span> &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;进程未正常退出，强制终止...&quot;</span></span><br><span class="line">        pkill -9 -x <span class="string">&quot;frps&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确认进程已停止</span></span><br><span class="line">    <span class="keyword">if</span> pgrep -x <span class="string">&quot;frps&quot;</span> &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;错误: 无法停止 frps&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;frps 已成功停止&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;frps 未运行&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p><strong>添加文件操作权限</strong>，后续直接运行文件即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x start_frps.sh stop_frps.sh</span><br></pre></td></tr></table></figure><p><strong>使用方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">./start_frps.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">./stop_frps.sh</span><br></pre></td></tr></table></figure><h4 id="客户端脚本"><a href="#客户端脚本" class="headerlink" title="客户端脚本"></a>客户端脚本</h4><p><strong>特性</strong>：</p><ul><li>自动重连机制</li></ul><p>新建启动文件 <code>start_frpc.bat</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">REM FRP Client Startup Script (with auto-reconnection mechanism)</span><br><span class="line">REM When frpc exits due to network fluctuations or other reasons, it will automatically restart</span><br><span class="line"></span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line"></span><br><span class="line">REM Get script directory</span><br><span class="line">set &quot;SCRIPT_DIR=%~dp0&quot;</span><br><span class="line">set &quot;FRPC_BIN=%SCRIPT_DIR%frpc.exe&quot;</span><br><span class="line">set &quot;FRPC_CONFIG=%SCRIPT_DIR%frpc.toml&quot;</span><br><span class="line">set &quot;RESTART_DELAY=5&quot;</span><br><span class="line"></span><br><span class="line">REM Check if frpc.exe exists</span><br><span class="line">if not exist &quot;%FRPC_BIN%&quot; (</span><br><span class="line">    echo Error: frpc.exe file not found: %FRPC_BIN%</span><br><span class="line">    pause</span><br><span class="line">    exit /b 1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">REM Check if config file exists</span><br><span class="line">if not exist &quot;%FRPC_CONFIG%&quot; (</span><br><span class="line">    echo Error: Config file not found: %FRPC_CONFIG%</span><br><span class="line">    pause</span><br><span class="line">    exit /b 1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">REM Check if frpc is already running</span><br><span class="line">tasklist /FI &quot;IMAGENAME eq frpc.exe&quot; 2&gt;NUL | find /I /N &quot;frpc.exe&quot;&gt;NUL</span><br><span class="line">if &quot;%ERRORLEVEL%&quot;==&quot;0&quot; (</span><br><span class="line">    echo Warning: Detected frpc.exe is already running, please stop it first using stop_frpc.bat</span><br><span class="line">    pause</span><br><span class="line">    exit /b 1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">echo ========================================</span><br><span class="line">echo FRP Client Startup Script (with auto-reconnection)</span><br><span class="line">echo ========================================</span><br><span class="line">echo Config file: %FRPC_CONFIG%</span><br><span class="line">echo Restart delay: %RESTART_DELAY% seconds</span><br><span class="line">echo ========================================</span><br><span class="line">echo.</span><br><span class="line">echo Tip: Press Ctrl+C to stop the service</span><br><span class="line">echo.</span><br><span class="line"></span><br><span class="line">REM Set loop counter</span><br><span class="line">set &quot;RESTART_COUNT=0&quot;</span><br><span class="line"></span><br><span class="line">:LOOP</span><br><span class="line">set /a RESTART_COUNT+=1</span><br><span class="line"></span><br><span class="line">REM Display startup information</span><br><span class="line">set &quot;CURRENT_TIME=%DATE% %TIME%&quot;</span><br><span class="line">echo [%CURRENT_TIME%] Starting frpc (Attempt %RESTART_COUNT%)...</span><br><span class="line"></span><br><span class="line">REM Run frpc</span><br><span class="line">cd /d &quot;%SCRIPT_DIR%&quot;</span><br><span class="line">&quot;%FRPC_BIN%&quot; -c &quot;%FRPC_CONFIG%&quot;</span><br><span class="line">set &quot;EXIT_CODE=%ERRORLEVEL%&quot;</span><br><span class="line"></span><br><span class="line">REM Display exit information</span><br><span class="line">set &quot;CURRENT_TIME=%DATE% %TIME%&quot;</span><br><span class="line">echo [%CURRENT_TIME%] frpc exited with code: %EXIT_CODE%</span><br><span class="line"></span><br><span class="line">REM If user presses Ctrl+C, exit code may be 0 or non-zero, but mainly check if interrupted</span><br><span class="line">REM We always try to restart here (unless user stops manually)</span><br><span class="line"></span><br><span class="line">REM Wait for specified time before restarting</span><br><span class="line">echo [%CURRENT_TIME%] Auto-restarting in %RESTART_DELAY% seconds...</span><br><span class="line">timeout /t %RESTART_DELAY% /nobreak &gt;nul</span><br><span class="line"></span><br><span class="line">REM Check if should continue (can add conditional checks here)</span><br><span class="line">REM If user wants to stop, should use stop_frpc.bat</span><br><span class="line"></span><br><span class="line">goto LOOP</span><br></pre></td></tr></table></figure><p><strong>使用方法</strong>：直接双击对应的 <code>.bat</code> 文件即可启动, 关闭 cmd 窗口即可关闭。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器：流量端口转发与代理</title>
      <link href="/2025/11/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9A%E6%B5%81%E9%87%8F%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E4%BB%A3%E7%90%86/"/>
      <url>/2025/11/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9A%E6%B5%81%E9%87%8F%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>实现 SSH 免密登录，并让云服务器流量转发到本地端口，通过代理再返回。</p><h2 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h2><p>打开 <code>~/.ssh/config</code>，写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host &lt;server ip&gt;</span><br><span class="line">    HostName &lt;server ip&gt;</span><br><span class="line">    User root           <span class="comment"># 默认为 root 用户</span></span><br><span class="line">    Port 22             <span class="comment"># SSH 默认端口</span></span><br></pre></td></tr></table></figure><p>打开 Cursor 的 Remote Explorer，会看到多了 <code>&lt;server ip&gt;</code> 这个选项。</p><p>现在配置免密</p><ol><li><p><strong>本机生成密钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519  <span class="comment"># 随便取一个文件名</span></span><br></pre></td></tr></table></figure></li><li><p><strong>公钥写入服务器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id ~/.ssh/id_ed25519.pub &lt;user&gt;@&lt;server-ip&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>验证免密登录</strong></p></li></ol><p>打开 Cursor 的 Remote Explorer，直接点击配置的 <code>&lt;server ip&gt;</code>；也可以使用命令行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh &lt;user&gt;@&lt;server-ip&gt;</span><br></pre></td></tr></table></figure><h2 id="端口转发与代理"><a href="#端口转发与代理" class="headerlink" title="端口转发与代理"></a>端口转发与代理</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>建立与云服务器的 SSH 正向隧道后，再搭建一条反向隧道（云服务器 -&gt; 本机）。以下以 “云服务器 1080 端口 ↔ 本机 7897 端口” 为例：</p><ul><li>云服务器访问外网时，将流量统一发到 1080 端口。</li><li>反向隧道把 1080 端口的流量转发到本机 7897。</li><li>本机 7897 端口交给代理软件，按节点分发，再把结果回传给云服务器。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>提供三种实现方法，实现方法三选一即可, 但是前置步骤要完成</p><h4 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h4><ol><li>在代理软件的端口设置中开启混合端口转发（以 7897 为例）。</li><li>在云服务器中配置环境变量，统一走 1080 端口。编辑 <code>~/.bashrc</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查代理是否可用并自动选择代理或直连</span></span><br><span class="line">PROXY_SERVER=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">PROXY_PORT=<span class="string">&quot;1080&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试代理是否可用</span></span><br><span class="line"><span class="keyword">if</span> curl -x socks5://<span class="variable">$PROXY_SERVER</span>:<span class="variable">$PROXY_PORT</span> -s --<span class="built_in">head</span> --max-time 5 https://www.google.com | grep <span class="string">&quot;HTTP/1.1 200 OK&quot;</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;代理可用，使用代理&quot;</span></span><br><span class="line">    <span class="built_in">export</span> ALL_PROXY=socks5://<span class="variable">$PROXY_SERVER</span>:<span class="variable">$PROXY_PORT</span></span><br><span class="line">    <span class="built_in">export</span> HTTP_PROXY=<span class="variable">$ALL_PROXY</span></span><br><span class="line">    <span class="built_in">export</span> HTTPS_PROXY=<span class="variable">$ALL_PROXY</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;代理不可用，切换到直连&quot;</span></span><br><span class="line">    <span class="built_in">unset</span> ALL_PROXY</span><br><span class="line">    <span class="built_in">unset</span> HTTP_PROXY</span><br><span class="line">    <span class="built_in">unset</span> HTTPS_PROXY</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>保存后运行 <code>source ~/.bashrc</code> 使其生效。</p><ol start="3"><li>编辑 <code>/etc/ssh/sshd_config</code>，将以下参数取消注释并设为 <code>yes</code>：<ul><li><code>AllowTcpForwarding</code>：允许 SSH 客户端发起本地&#x2F;远程端口转发。</li><li><code>GatewayPorts</code>：远程端口转发可绑定 <code>0.0.0.0/::</code>。</li><li><code>PermitTunnel</code>：允许基于 SSH 的三层隧道。</li></ul></li></ol><h4 id="三种方法"><a href="#三种方法" class="headerlink" title="三种方法"></a>三种方法</h4><p>注: 三种方法在云服务器上绑定的端口都是 1080, 最好用完一个方法就关闭, 而不是一起使用, 否则可能造成端口冲突</p><ol><li>写入本地 SSH 配置<br>在 <code>~/.ssh/config</code> 中（基于免密配置）写入：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Host &lt;server ip&gt;</span><br><span class="line">    HostName &lt;server ip&gt;</span><br><span class="line">    User root</span><br><span class="line">    Port 22</span><br><span class="line">    <span class="comment"># 追加下面三条即可</span></span><br><span class="line">    RemoteForward 1080 localhost:7897</span><br><span class="line">    ServerAliveInterval 30</span><br><span class="line">    ServerAliveCountMax 3</span><br></pre></td></tr></table></figure><p>写好后，Cursor 远程连接服务器时会自动启动反向隧道。</p><ol start="2"><li><p>使用脚本与工具保持隧道</p><ul><li>普通 SSH，一旦关闭终端会话就会断开：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -M 0 -f -N -v -o ServerAliveInterval=30 -o ServerAliveCountMax=3 \</span><br><span class="line">    -i ~/.ssh/&lt;key file name&gt; -R 1080:localhost:7897 &lt;user&gt;@&lt;server ip&gt;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>autossh</code> 可以保持连接，先通过 Homebrew 安装：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install autossh</span><br></pre></td></tr></table></figure><p>再写脚本方便启动和提示：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件名 start_ssh_tunnel.sh</span></span><br><span class="line">autossh -M 0 -f -N -v -o ServerAliveInterval=30 -o ServerAliveCountMax=3 -i ~/.ssh/&lt;key file name&gt; -R 1080:localhost:7897 &lt;user&gt;@&lt;server ip&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;\033[32m✅ 隧道启动成功！\033[0m&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;📌 验证方法：&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;  1. Mac 端查看进程：ps aux | grep autossh&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;  2. 服务器端查看端口：ss -tulnp | grep :1080&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;  3. 关闭隧道：pkill autossh&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;\033[31m❌ 隧道启动失败！\033[0m&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;🔍 可能原因：&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;  1. autossh 未安装（执行 brew install autossh）&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;  2. 密钥路径错误（当前路径：~/.ssh/id_rsa）&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;  3. 服务器 1080 端口被占用&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>后续操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开端口转发</span></span><br><span class="line">./start_ssh_tunnel.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭端口转发</span></span><br><span class="line">pkill autossh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 autossh 相关进程（含 grep 本身）</span></span><br><span class="line">ps aux | grep autossh</span><br></pre></td></tr></table></figure><ol start="3"><li><p>Termius 配置端口转发<br>在 Termius 左侧 Port Forwarding 中新建规则：</p><ul><li>Remote host: <code>&lt;server ip&gt;</code></li><li>Remote port: <code>1080</code></li><li>Bind address: <code>127.0.0.1</code></li><li>Destination address: <code>127.0.0.1</code></li><li>Destination port: <code>7897</code></li></ul><p>没搞懂 Bind address 和 Destination address 的区别<br>不过确认 Termius 显示 <code>From &lt;server ip&gt;:1080 to 127.0.0.1:7897</code> 即表示已连通，启用后再连接服务器即可完成转发。</p></li></ol><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试要使用 <code>curl</code>, 而不能使用 <code>ping</code><br>因为 <code>ping</code> 基于 <code>ICMP</code> 协议, 运行在网络层，而我们配置的 SSH 端口转发 + 代理仅支持 <code>TCP</code>&#x2F;<code>UDP</code> 协议，<code>ICMP</code> 数据包无法通过代理隧道转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求国内网络</span></span><br><span class="line">curl -v https://baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求国外网络</span></span><br><span class="line">curl -v https://google.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastGPT实习：系统插件项目构建与插件生态贡献</title>
      <link href="/2025/10/18/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%8F%92%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%8F%92%E4%BB%B6%E7%94%9F%E6%80%81%E8%B4%A1%E7%8C%AE/"/>
      <url>/2025/10/18/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%8F%92%E4%BB%B6%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%8F%92%E4%BB%B6%E7%94%9F%E6%80%81%E8%B4%A1%E7%8C%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="系统插件项目构建"><a href="#系统插件项目构建" class="headerlink" title="系统插件项目构建"></a>系统插件项目构建</h2><p>通过三个机制实现插件项目快速构建</p><h3 id="1-零配置机制"><a href="#1-零配置机制" class="headerlink" title="1. 零配置机制"></a>1. 零配置机制</h3><p><strong>两个核心机制:</strong></p><ul><li>约定优于配置</li><li>自动发现机制</li></ul><p><strong>实现细节:</strong></p><ul><li><strong>系统启动</strong>: 系统启动时调用initTools, 包含initBuiltInTools和refreshUploadedTools两部分</li><li><strong>自动发现</strong>: 判断是开发环境还是生产环境, 扫描对应的路径目录, 得到工具目录数组, 对于工具目录数组的每一个元素(工具目录), 调用LoadToolsByFilename, Filename即目录名称</li><li><strong>动态加载</strong>: 动态导入插件, 识别是工具还是工具集, 约定默认toolId和icon, 加载工具(或副工具集下的所有子工具)</li><li><strong>自动注册</strong>: 将加载的工具添加到全局插件列表, 实现插件自动可用, 无需手动配置</li></ul><h3 id="2-脚本一键生成模板"><a href="#2-脚本一键生成模板" class="headerlink" title="2. 脚本一键生成模板"></a>2. 脚本一键生成模板</h3><ul><li>使用nodejs全局变量: <code>__dirname</code>, <code>process</code></li><li>提前创建好工具和工具集模板</li><li><code>copyTemplate</code>函数: 如果是文件夹则递归调用, 如果是文件则复制, 这样就把模板变成能实际开发的代码结构</li></ul><h3 id="3-插件热插拔"><a href="#3-插件热插拔" class="headerlink" title="3. 插件热插拔"></a>3. 插件热插拔</h3><p>系统插件分为内置插件和用户自定义插件两部分, 插件热插拔针对的是用户自定义插件这一部分</p><p><strong>本质</strong>: 插件刷新机制, 分为通知, 检查, 执行三部分, 其中通知发生在用户上传&#x2F;删除插件请求, 检查和执行发生在获取插件列表请求</p><ul><li><p><strong>通知</strong>: <code>refreshVersionKey</code> 刷新版本键</p><ul><li>版本键存储在redis中, 用户每一次添加或删除自定义插件, 都生成新的uuid作为新的版本键, 解决分布式环境下数据一致性的问题(不同服务实例发现版本键更新, 就会重新加载系统插件)</li><li>用于通知系统, 下一次刷新时, 插件有变化</li></ul></li><li><p><strong>检测</strong>: <code>getCachedData</code> 封装好的获取缓存函数</p><ul><li>下一次请求时, 要获取插件列表, 在获取前先调用getCachedData, 检测缓存中的版本键是否变化</li><li>检测到版本键变化, 调用refreshUploadedTools, 重新加载插件</li></ul></li><li><p><strong>执行</strong>: <code>refreshUploadedTools</code> 刷新插件</p><ul><li>实现: 获取当前内存中的插件和数据库中的插件, 比较差异, 找出需要删除和需要新增的插件, 并行删除和新增, 并重新初始化”用户自定义插件”列表</li></ul></li></ul><h3 id="4-插件热插拔的拓展-插件的存储方式"><a href="#4-插件热插拔的拓展-插件的存储方式" class="headerlink" title="4. 插件热插拔的拓展: 插件的存储方式"></a>4. 插件热插拔的拓展: 插件的存储方式</h3><ul><li><strong>S3</strong>: 存储插件的具体文件内容</li><li><strong>MongoDB</strong>: 存储插件的元数据, 便于管理, 查找</li><li><strong>本地文件</strong>: 内置插件和用户自定义插件的本地缓存(其实是存在磁盘而不是内存中), 避免每次执行都要网络请求, 加快执行速度</li></ul><h2 id="主线程与子线程"><a href="#主线程与子线程" class="headerlink" title="主线程与子线程"></a>主线程与子线程</h2><p>系统插件支持主线程运行和子线程运行两种模式, 通过在插件中配置<code>isWorkerRun</code>字段即可指定<br>某些插件涉及网络请求或者复杂计算, 放在子线程中执行能有效防止主线程阻塞导致的工作流整体阻塞</p><p><strong>流程</strong>: HTTP请求运行插件, 检查<code>isWorkerRun</code>, false则主线程执行插件, true则创建子线程Worker, 执行子线程</p><p><strong>HTTP流响应实现</strong>: 主线程传递一个回调函数给子线程, 子线程产生了流式数据后, 调用回调函数, 将数据传给主线程, 主线程再包装成HTTP响应发送出去</p><p><strong>原因</strong>: 主线程response对象无法跨线程传递, HTTP连接绑定的是主线程的Socket, 子线程有独立的事件循环, 无法访问主线程的事件循环</p><h2 id="插件生态贡献"><a href="#插件生态贡献" class="headerlink" title="插件生态贡献"></a>插件生态贡献</h2><p>贡献了15个系统插件, 丰富了整个插件生态, 尤其是多模态领域</p><p><strong>15个插件有</strong>: base64转图片, 墨迹天气每日天气查询, chatppt文生ppt, nano banana文生图, base64转文件, minimax tts, md转ppt, 阿里云百炼通义千问图像编辑, 豆包seedream图像编辑, 豆包音乐生成模型, 36kr新闻热榜, 每日新闻热榜, gpt-image图像编辑, whisper stt, sora2</p><p><strong>分类</strong>:</p><ul><li><strong>多模态</strong>: chatppt文生ppt, nano banana文生图, minimax tts, 阿里云百炼通义千问图像编辑, 豆包seedream图像编辑, 豆包音乐生成模型, gpt-image图像编辑, whisper stt, sora2</li><li><strong>工具类</strong>: base64转图片, base64转文件, md转ppt</li><li><strong>实用类</strong>: 墨迹天气每日天气查询, 36kr新闻热榜, 每日新闻热榜</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 实习经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastGPT实习：工作流运行机制与调试模式</title>
      <link href="/2025/10/17/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/10/17/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="工作流基本数据结构"><a href="#工作流基本数据结构" class="headerlink" title="工作流基本数据结构"></a>工作流基本数据结构</h1><ul><li><strong>节点 Node</strong>: 工作流的基本执行单元，包含输入、输出、执行逻辑</li><li><strong>边 Edge</strong>: 连接节点的有向边，三种状态：<ul><li><code>active</code>: 激活状态，表示数据流经此边</li><li><code>skipped</code>: 跳过状态，表示此边被跳过</li><li><code>waiting</code>: 等待状态，表示等待上游节点执行完成</li></ul></li><li><strong>连接点 Handle</strong>: 节点上的输入输出连接点，一个节点可能有多个handle</li><li><strong>活跃节点队列 activeRunQueue</strong>: 存储准备执行的节点ID集合</li><li><strong>跳过节点队列 skipNodeQueue</strong>: 存储需要跳过的节点及其子节点映射</li><li><strong>调试数据结构</strong>:<ul><li><code>debugNextStepRunNodes</code>: 调试模式下存储下一步要执行的节点</li><li><code>debugNodeResponses</code>: 调试模式下记录每个节点的执行结果</li></ul></li></ul><h1 id="补充概念"><a href="#补充概念" class="headerlink" title="补充概念"></a>补充概念</h1><h2 id="入口节点-Entry-Node"><a href="#入口节点-Entry-Node" class="headerlink" title="入口节点 (Entry Node)"></a>入口节点 (Entry Node)</h2><ul><li>工作流的起始执行点</li><li>通过 <code>isEntry</code> 属性标识</li><li>调试模式下，每次步骤的入口节点由前端动态设置</li></ul><h2 id="交互节点-Interactive-Node-代码逻辑上-判断节点时单独判断-处理交互节点"><a href="#交互节点-Interactive-Node-代码逻辑上-判断节点时单独判断-处理交互节点" class="headerlink" title="交互节点 (Interactive Node) (代码逻辑上:判断节点时单独判断,处理交互节点)"></a>交互节点 (Interactive Node) (代码逻辑上:判断节点时单独判断,处理交互节点)</h2><ul><li>需要用户输入的节点（如用户选择、表单输入等）</li><li>执行后会暂停工作流，等待用户响应</li><li>调试模式下特别处理，保持入口状态</li></ul><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ul><li>通过 <code>maxConcurrency</code> 限制同时执行的节点数量</li><li>防止资源过载，提高系统稳定性</li></ul><h1 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h1><p>采用双队列机制，有效避免深度递归</p><h2 id="节点状态判断逻辑"><a href="#节点状态判断逻辑" class="headerlink" title="节点状态判断逻辑"></a>节点状态判断逻辑</h2><ul><li>节点状态由<strong>所有输入边</strong>的状态决定：<ul><li>所有输入边均为 <code>active</code> → 节点状态为 <code>run</code>（执行）</li><li>所有输入边均为 <code>skipped</code> → 节点状态为 <code>skip</code>（跳过）</li><li>存在 <code>waiting</code> 边 → 节点状态为 <code>wait</code>（等待）</li><li>混合状态（部分 <code>active</code>，部分 <code>skipped</code>）→ 节点状态为 <code>skip</code>（跳过）</li></ul></li></ul><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ol><li>从入口节点开始运行工作流</li><li>当节点状态为 <code>run</code> 时，进入活跃队列，检查运行条件（并发数限制），满足则立即执行</li><li>当节点状态为 <code>skip</code> 时，进入跳过队列，只有活跃队列全部执行完，才会执行跳过队列的节点<ul><li>执行跳过队列指的是更新节点与边的状态，而不是执行节点的具体逻辑</li><li>因为只有更新全部的边状态（所有边不为 <code>waiting</code>），才能判断所有的节点的状态</li></ul></li><li>每执行一次跳过节点，就要重新检测活跃队列是否产生新的活跃节点，有则停止执行跳过队列，去执行活跃队列</li></ol><h1 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h1><h2 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h2><ul><li><code>debugNextStepRunNodes</code>: 存储下一步要执行的节点，不立即执行，等待用户手动触发</li><li><code>debugNodeResponses</code>: 记录每个节点的执行结果，包括运行状态、响应内容、交互响应等</li></ul><h2 id="调试模式特点"><a href="#调试模式特点" class="headerlink" title="调试模式特点"></a>调试模式特点</h2><ol><li><p><strong>阶段性返回</strong>：</p><ul><li>有下一步节点：立即返回，等待用户点击下一步</li><li>无下一步节点但有跳过节点：处理跳过节点</li><li>完全结束：返回最终结果</li></ul></li><li><p><strong>延迟执行</strong>：</p><ul><li>运行模式：下游节点加入 <code>activeRunQueue</code>，并立即执行</li><li>调试模式：下游节点加入 <code>debugNextStepRunNodes</code>，等待用户手动触发下一步</li></ul></li><li><p><strong>动态设置入口节点</strong>：</p><ul><li>前端点击下一步时，发送 <code>isEntry = true</code>，后端接收到标识，把下一个节点标记为 <code>entry</code></li><li>保证了运行模式和调试模式的代码复用</li></ul></li><li><p><strong>数据收集</strong>：</p><ul><li>每一次运行完一个节点后，使用 <code>getDebugResponse</code>，收集该节点执行后的相关信息返回给前端</li><li>更新边状态，便于用户点击下一步</li></ul></li><li><p><strong>前端API接口</strong>：</p><ul><li>提供 <code>/api/core/workflow/debug</code> 接口，调用调试模式工作流引擎(即上文)</li><li>前端封装 <code>postWorkflowDebug</code> 函数调用此接口</li></ul></li><li><p><strong>前端交互逻辑</strong>：</p><ul><li><code>onStartNodeDebug</code>: 启动调试，构建初始数据</li><li><code>onNextNodeDebug</code>: 执行单步调试，不自动继续</li><li>用户通过”下一步”按钮手动控制每一步的执行</li></ul></li></ol><h2 id="前端实现-todo"><a href="#前端实现-todo" class="headerlink" title="前端实现(todo)"></a>前端实现(todo)</h2><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><ul><li><code>workflowDebugData</code>: 存储当前调试状态</li><li>节点状态更新：<code>debugResult</code> 属性记录执行结果</li></ul><h3 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h3><ul><li>“开始调试”按钮：调用 <code>onStartNodeDebug</code></li><li>“下一步”按钮：调用 <code>onNextNodeDebug</code></li><li>“停止调试”按钮：调用 <code>onStopNodeDebug</code></li></ul><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><ul><li>实时显示节点执行状态</li><li>高亮显示当前执行的节点</li><li>显示节点执行结果和响应内容</li><li>支持查看变量值和边状态</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 实习经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastGPT实习：AI流式响应全链路分析</title>
      <link href="/2025/10/12/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9AAI%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94%E5%85%A8%E9%93%BE%E8%B7%AF%E5%88%86%E6%9E%90/"/>
      <url>/2025/10/12/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9AAI%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94%E5%85%A8%E9%93%BE%E8%B7%AF%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>在AI应用中，实现向AI模型请求提问并返回流式响应，最终呈现打字机输出效果。这种交互方式能够提升用户体验，让AI的回答更加自然流畅。</p><h2 id="技术架构分析"><a href="#技术架构分析" class="headerlink" title="技术架构分析"></a>技术架构分析</h2><h3 id="整体流程概览"><a href="#整体流程概览" class="headerlink" title="整体流程概览"></a>整体流程概览</h3><p>整个流式响应系统涉及6个关键环节：</p><ol><li><strong>前端发起SSE连接</strong></li><li><strong>后端接收请求并调用AI模型</strong></li><li><strong>AI模型流式响应给后端</strong></li><li><strong>后端设置SSE响应头并流式发送</strong></li><li><strong>前端流式接收数据</strong></li><li><strong>渲染组件实现打字机效果</strong></li></ol><h3 id="详细技术实现"><a href="#详细技术实现" class="headerlink" title="详细技术实现"></a>详细技术实现</h3><h4 id="1-前端发起SSE连接"><a href="#1-前端发起SSE连接" class="headerlink" title="1. 前端发起SSE连接"></a>1. 前端发起SSE连接</h4><p>前端使用Server-Sent Events技术建立与后端的持久连接，为后续的流式数据传输做准备。</p><h4 id="2-后端接收请求并调用AI模型"><a href="#2-后端接收请求并调用AI模型" class="headerlink" title="2. 后端接收请求并调用AI模型"></a>2. 后端接收请求并调用AI模型</h4><p>后端接收前端的请求后，调用AI模型API获取响应。</p><h4 id="3-AI模型流式响应处理"><a href="#3-AI模型流式响应处理" class="headerlink" title="3. AI模型流式响应处理"></a>3. AI模型流式响应处理</h4><p><strong>核心机制：异步迭代器</strong></p><p>AI模型返回一个异步迭代器给后端，而不是完整的响应数据。异步迭代器就像一个数据管道，让后端可以通过<code>for await</code>循环实时获取AI生成的数据。</p><p><strong>数据内容包含：</strong></p><ul><li>元数据信息</li><li>标签数据</li><li>推理内容</li><li>回答内容</li></ul><p><strong>处理流程：</strong></p><ul><li>持续接收数据直到用户手动退出或AI模型生成完毕</li><li>数据分批次到达，需要特殊处理机制</li></ul><h4 id="4-函数工厂模式实现状态管理"><a href="#4-函数工厂模式实现状态管理" class="headerlink" title="4. 函数工厂模式实现状态管理"></a>4. 函数工厂模式实现状态管理</h4><p><strong>设计原理：</strong><br>由于流式处理中数据分批次到达，采用函数工厂模式配合闭包来维持内部状态。</p><p><strong>工厂函数返回三个核心函数：</strong></p><ul><li><strong>流式数据解析器</strong>：解析异步迭代器产生的数据，分离推理内容和回答内容，并将内容累加到缓冲区</li><li><strong>完整响应数据获取器</strong>：获取累加后的全部数据（包含推理内容、回答内容、完成原因、使用统计）</li><li><strong>完成原因更新器</strong>：用于发生错误时手动更新结束原因</li></ul><p><strong>优势：</strong><br>通过闭包实现状态隔离与共享，各函数各司其职又能互相通信。</p><h4 id="5-后端SSE响应设置"><a href="#5-后端SSE响应设置" class="headerlink" title="5. 后端SSE响应设置"></a>5. 后端SSE响应设置</h4><p><strong>响应头配置：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/event-stream</span><br></pre></td></tr></table></figure><p><strong>发送机制：</strong><br>使用回调函数让工厂函数解析出的函数控制发送时机，实现精准的流式数据传输。</p><h4 id="6-前端流式接收与处理"><a href="#6-前端流式接收与处理" class="headerlink" title="6. 前端流式接收与处理"></a>6. 前端流式接收与处理</h4><p><strong>核心处理机制：</strong></p><ol><li><strong>缓冲机制</strong>：接收的字符存入数据队列，控制打字机效果的显示速率</li><li><strong>平滑处理</strong>：使用<code>requestAnimationFrame</code> API在合适的时机执行动画处理函数，自动与浏览器刷新率同步</li><li><strong>持续动画</strong>：通过<code>requestAnimationFrame</code>递归调用动画处理函数</li></ol><h4 id="7-组件渲染与状态更新"><a href="#7-组件渲染与状态更新" class="headerlink" title="7. 组件渲染与状态更新"></a>7. 组件渲染与状态更新</h4><p>更新全局状态，触发UI重渲染，最终实现流畅的打字机效果。</p><h2 id="关键技术点解析"><a href="#关键技术点解析" class="headerlink" title="关键技术点解析"></a>关键技术点解析</h2><h3 id="Server-Sent-Events-SSE"><a href="#Server-Sent-Events-SSE" class="headerlink" title="Server-Sent Events (SSE)"></a>Server-Sent Events (SSE)</h3><p><strong>传统HTTP请求流程：</strong></p><p>客户端发起请求 → 服务器处理 → 返回完整响应 → 连接关闭</p><p><strong>SSE连接流程：</strong></p><p>客户端发起 SSE 连接 → 服务器保持连接 → 分批次推送数据 → 客户端实时处理 → 完成后关闭连接</p><p><strong>SSE优势：</strong></p><ul><li>保持长连接，减少连接开销</li><li>支持服务器主动推送数据</li><li>自动重连机制</li><li>轻量级，比WebSocket更简单</li></ul><h3 id="函数工厂设计模式"><a href="#函数工厂设计模式" class="headerlink" title="函数工厂设计模式"></a>函数工厂设计模式</h3><p><strong>核心思想：</strong><br>结合闭包特性，实现状态隔离与共享状态的平衡。</p><p><strong>应用场景：</strong></p><ul><li>需要维持内部状态的函数集合</li><li>需要状态隔离但又要相互通信的场景</li><li>流式数据处理中的状态管理</li></ul><p><strong>实现效果：</strong><br>通过工厂函数返回的函数集合，既保持了各自职责的独立性，又通过共享的闭包状态实现了协作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过SSE技术和函数工厂模式的结合，成功实现了AI流式响应的全链路处理。这种架构不仅保证了数据传输的实时性，还通过合理的状态管理确保了系统的稳定性和可维护性。在前端实现上，通过缓冲机制和平滑动画处理，为用户提供了流畅的打字机交互体验。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastGPT实习：双Token验证实现CSRF防御</title>
      <link href="/2025/10/12/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E5%8F%8CToken%E9%AA%8C%E8%AF%81%E5%AE%9E%E7%8E%B0CSRF%E9%98%B2%E5%BE%A1/"/>
      <url>/2025/10/12/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E5%8F%8CToken%E9%AA%8C%E8%AF%81%E5%AE%9E%E7%8E%B0CSRF%E9%98%B2%E5%BE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="双Token验证实现CSRF防御"><a href="#双Token验证实现CSRF防御" class="headerlink" title="双Token验证实现CSRF防御"></a>双Token验证实现CSRF防御</h1><p>需求分析：在 FastGPT 平台发现安全漏洞，发送markdown渲染的img标签，如果src属性为”删除api”的路径（如：<code>/api/core/dataset/delete</code>），则会将用户的知识库自动删除</p><p>通过实现双Token验证机制，有效防御CSRF（跨站请求伪造）攻击</p><p>保护用户数据安全，防止恶意站点利用用户身份执行敏感操作</p><hr><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>发送markdown渲染的img标签，如果src属性为”删除api”的路径（如：<code>/api/core/dataset/delete</code>），则会将用户的知识库自动删除</p><h3 id="问题本质"><a href="#问题本质" class="headerlink" title="问题本质"></a>问题本质</h3><p>由于前端请求自动携带浏览器cookie作为请求头，后端校验通过后，执行图片中的路径，造成CSRF恶意攻击</p><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><ol><li>用户已登录平台，浏览器中存储cookie信息</li><li>恶意站点的某些表单、图片等请求指向平台的敏感接口</li><li>当用户被诱导访问后，浏览器会在请求中自动添加cookie</li><li>仅凭Cookie做鉴权的服务端误以为是用户本人操作，执行敏感动作</li></ol><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="技术方案：双Token验证"><a href="#技术方案：双Token验证" class="headerlink" title="技术方案：双Token验证"></a>技术方案：双Token验证</h3><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li><p><strong>前端Token获取</strong>：</p><ul><li>前端发送请求前，检测本地存储中没有<code>csrf_token</code>，或者过期时间小于阈值时间</li><li>主动请求后端生成<code>csrf_token</code>，前端接受后解密出token值和过期时间</li><li>保存在本地存储中</li></ul></li><li><p><strong>请求头设置</strong>：</p><ul><li>前端在请求前设置<code>x-csrf-token</code>请求头</li><li>值为本地存储中<code>csrf_token</code>的值</li></ul></li><li><p><strong>后端验证</strong>：</p><ul><li>后端收到请求后，从cookie中拿到<code>csrf_token</code></li><li>从请求头中拿到<code>x-csrf-token</code></li><li>验证两个值是否过期，是否相等</li><li>没有问题后再验证通过</li></ul></li><li><p><strong>自动下发</strong>：</p><ul><li>后端检测到请求头没有<code>x-csrf-token</code>时，要主动生成token下发给前端</li></ul></li></ol><hr><h2 id="防御效果"><a href="#防御效果" class="headerlink" title="防御效果"></a>防御效果</h2><h3 id="成功防御案例"><a href="#成功防御案例" class="headerlink" title="成功防御案例"></a>成功防御案例</h3><p>如果添加了双Token验证：</p><ol><li>恶意站点与平台不同源，所以读取不到cookie</li><li>无法配置cookie和请求头</li><li>从而无法通过验证，有效防御CSRF攻击</li></ol><h3 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h3><ul><li><strong>双重验证</strong>：cookie中的token + 请求头中的token</li><li><strong>时效性控制</strong>：token具有过期时间</li><li><strong>同源策略</strong>：恶意站点无法获取有效token</li></ul><hr><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="重要注意事项"><a href="#重要注意事项" class="headerlink" title="重要注意事项"></a>重要注意事项</h3><ol><li><p><strong>Cookie安全</strong>：</p><ul><li>因为要禁止cookie能通过JS脚本获取，所以要给cookie加上<code>httpOnly</code>属性</li><li>而<code>csrf_token</code>值又需要添加到请求头中，所以要在本地存储中存<code>csrf_token</code></li></ul></li><li><p><strong>避免循环</strong>：</p><ul><li>生成<code>csrf_token</code>的接口要跳过<code>csrf_token</code>的验证</li><li>否则会陷入循环请求的死循环中</li></ul></li></ol><h3 id="实现优势"><a href="#实现优势" class="headerlink" title="实现优势"></a>实现优势</h3><ul><li><strong>安全性高</strong>：双重验证机制，有效防御CSRF攻击</li><li><strong>用户体验好</strong>：自动处理token获取和验证</li><li><strong>维护性强</strong>：逻辑清晰，易于维护和扩展</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过实现双Token验证机制，成功解决了FastGPT平台的CSRF安全漏洞</p><p>这种防御机制不仅保护了用户数据安全，也为类似的安全问题提供了解决方案</p><p>在现代Web应用中，CSRF防御是必不可少的安全措施，双Token验证是一种有效且实用的实现方案</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastGPT实习：从渲染和请求的时序中学习React设计哲学</title>
      <link href="/2025/10/08/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E4%BB%8E%E6%B8%B2%E6%9F%93%E5%92%8C%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%BA%8F%E4%B8%AD%E5%AD%A6%E4%B9%A0React%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/"/>
      <url>/2025/10/08/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E4%BB%8E%E6%B8%B2%E6%9F%93%E5%92%8C%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%BA%8F%E4%B8%AD%E5%AD%A6%E4%B9%A0React%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="从渲染和请求的时序中学习React设计哲学"><a href="#从渲染和请求的时序中学习React设计哲学" class="headerlink" title="从渲染和请求的时序中学习React设计哲学"></a>从渲染和请求的时序中学习React设计哲学</h1><p>需求分析：在 FastGPT 平台开发过程中，遇到组件渲染与异步请求时序问题</p><p>通过解决组件渲染空数组的问题，深入理解 React 的异步渲染机制和设计哲学</p><p>学习如何优雅地处理异步数据加载与组件渲染的协调</p><hr><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>打开一个modal时, 网络请求已经获取到了数据, 但是modal没有渲染出数据</p><h3 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h3><p>组件渲染和API请求是异步进行的，导致组件优先渲染了变量的初值（空数组）</p><p>当异步请求获取到数据，填充到数组中时，组件已经渲染完毕了</p><p>最终结果就是渲染了空数组</p><h3 id="问题影响"><a href="#问题影响" class="headerlink" title="问题影响"></a>问题影响</h3><ul><li>用户看到空白或加载状态</li><li>数据更新后界面不会自动刷新</li><li>用户体验不佳</li></ul><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h3><p>使用 <code>useMemo</code> 来缓存数组，并将请求的数据变量作为依赖项</p><p>请求成功，依赖项变化，更新数组，进而重新渲染组件</p><p>解决渲染空数组的问题</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol><li>组件初始渲染时显示空数组</li><li>异步请求开始执行</li><li>请求完成后，依赖项更新</li><li><code>useMemo</code> 检测到依赖变化，重新计算</li><li>组件重新渲染，显示实际数据</li></ol><hr><h2 id="方案优点"><a href="#方案优点" class="headerlink" title="方案优点"></a>方案优点</h2><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>不会因为某一个数组在加载中，而阻塞渲染，让整个组件树等待，提升使用体验</p><p>可以让多个数据源同时加载，并发渲染</p><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><ul><li>页面快速响应，不会出现长时间白屏</li><li>数据加载过程中有明确的加载状态</li><li>数据更新后界面自动刷新</li></ul><hr><h2 id="React-的设计哲学"><a href="#React-的设计哲学" class="headerlink" title="React 的设计哲学"></a>React 的设计哲学</h2><h3 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h3><p>React 遵循以下设计原则：</p><ol><li><strong>组件先渲染初始状态</strong>（loading 或 empty state）</li><li><strong>异步获取数据</strong></li><li><strong>数据返回后重新渲染</strong>（显示实际内容）</li></ol><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>这种设计哲学使得 React 应用能够：</p><ul><li>快速响应用户交互</li><li>优雅地处理异步数据</li><li>提供良好的用户体验</li><li>支持复杂的应用状态管理</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过解决异步请求与组件渲染的时序问题，深入理解了 React 的设计哲学</p><p>React 鼓励开发者将异步操作与 UI 渲染解耦，通过声明式的方式管理状态</p><p>这种设计不仅提升了性能，也改善了用户体验，是现代前端框架的重要特征</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastGPT实习：扫描二维码实现自动兑换积分</title>
      <link href="/2025/10/07/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%85%91%E6%8D%A2%E7%A7%AF%E5%88%86/"/>
      <url>/2025/10/07/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%85%91%E6%8D%A2%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="扫描二维码实现自动兑换积分的完整流程"><a href="#扫描二维码实现自动兑换积分的完整流程" class="headerlink" title="扫描二维码实现自动兑换积分的完整流程"></a>扫描二维码实现自动兑换积分的完整流程</h1><p>需求分析：在 FastGPT 平台实现用户扫描二维码自动兑换积分功能</p><p>用户扫描包含兑换码信息的二维码，自动跳转到门户网站登录页，登录成功后，自动兑换兑换码，增加账号积分</p><p>实现用户无需手动输入兑换码，提升用户体验</p><hr><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="二维码的本质"><a href="#二维码的本质" class="headerlink" title="二维码的本质"></a>二维码的本质</h3><p>二维码的本质是用二维图形存储二进制数据的信息载体</p><p>扫描一次二维码的本质是通过光学识别将图形转化为二进制数据，再解码出二维码中包含的数据，并执行</p><h3 id="二维码需要包含的信息"><a href="#二维码需要包含的信息" class="headerlink" title="二维码需要包含的信息"></a>二维码需要包含的信息</h3><ol><li>重定向地址</li><li>兑换码</li><li>兑换码是否被使用</li></ol><h3 id="实现登录后自动兑换的方案"><a href="#实现登录后自动兑换的方案" class="headerlink" title="实现登录后自动兑换的方案"></a>实现登录后自动兑换的方案</h3><h4 id="方案A：携带查询参数到登录页"><a href="#方案A：携带查询参数到登录页" class="headerlink" title="方案A：携带查询参数到登录页"></a>方案A：携带查询参数到登录页</h4><p>扫描二维码后, 会重定向到登录页, 同时url中会携带兑换码信息作为查询参数</p><p>登录接口会接收查询参数中的兑换码信息, 并在登录成功后再传递给兑换接口</p><p>兑换接口在收到兑换码信息后执行, 即可兑换积分</p><h4 id="方案B：使用本地存储"><a href="#方案B：使用本地存储" class="headerlink" title="方案B：使用本地存储"></a>方案B：使用本地存储</h4><p>扫码跳转登录页后，将兑换码存储在本地存储</p><p>登录后检测本地存储，符合条件则执行兑换API，并删除存储</p><hr><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>选择方案B</p><p>原因:</p><ol><li>登录接口有多种, 微信登录, 账密登录等等, 选择方案A的话每个接口都需要修改</li><li>修改底层登录接口这种行为, 入侵性太强, 不适合</li></ol><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>拼接门户网站URL和查询参数为一个重定向地址，用重定向地址生成二维码</li><li>跳转登录页后，检测URL查询参数包含兑换码，取出并存在本地存储</li><li>新写一个hook，挂载在layout文件中，实现登录成功后，从本地存储中取出兑换码，并执行兑换API，删除存储</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>登录成功，进入页面后自动执行，同时不破坏代码原有的逻辑结构，未来还可以拓展</li><li>符合React的钩子设计哲学(声明式而不是命令式)</li><li>实现登录与兑换解耦</li></ol><hr><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>用户扫描二维码后，整个兑换流程自动化完成，无需手动操作，大大提升了用户体验</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>用户体验流畅，无需手动输入兑换码</li><li>代码侵入性小，不破坏原有架构</li><li>可扩展性强，未来可以支持更多功能</li></ul><h3 id="后续优化方向"><a href="#后续优化方向" class="headerlink" title="后续优化方向"></a>后续优化方向</h3><ul><li>增加兑换码的有效期验证</li><li>支持批量兑换码处理</li><li>添加兑换记录和日志功能</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 实习经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastGPT实习：HTTP插件改造为HTTP工具集</title>
      <link href="/2025/10/05/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9AHTTP%E6%8F%92%E4%BB%B6%E6%94%B9%E9%80%A0%E4%B8%BAHTTP%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
      <url>/2025/10/05/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9AHTTP%E6%8F%92%E4%BB%B6%E6%94%B9%E9%80%A0%E4%B8%BAHTTP%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="FastGPT实习：HTTP插件改造为HTTP工具集"><a href="#FastGPT实习：HTTP插件改造为HTTP工具集" class="headerlink" title="FastGPT实习：HTTP插件改造为HTTP工具集"></a>FastGPT实习：HTTP插件改造为HTTP工具集</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>负责FastGPT开源项目中HTTP插件的重大架构升级，将原有的单一HTTP插件重构为灵活的HTTP工具集系统，提升了系统的可扩展性和用户体验。</p><hr><h2 id="核心工作内容"><a href="#核心工作内容" class="headerlink" title="核心工作内容"></a>核心工作内容</h2><h3 id="架构设计与重构"><a href="#架构设计与重构" class="headerlink" title="架构设计与重构"></a>架构设计与重构</h3><ul><li>将原有的单一HTTP插件（httpPlugin）重构为HTTP工具集（httpToolSet）</li><li>支持在一个工具集中管理多个HTTP工具</li></ul><h3 id="全栈开发"><a href="#全栈开发" class="headerlink" title="全栈开发"></a>全栈开发</h3><ul><li>独立完成前后端完整开发</li><li>包括React前端界面、Node.js后端API、数据库模型设计</li></ul><h3 id="工具集管理系统"><a href="#工具集管理系统" class="headerlink" title="工具集管理系统"></a>工具集管理系统</h3><ul><li>实现HTTP工具的CRUD操作</li><li>支持OpenAPI规范解析，自动生成工具配置</li></ul><h3 id="灵活配置能力"><a href="#灵活配置能力" class="headerlink" title="灵活配置能力"></a>灵活配置能力</h3><ul><li>支持自定义请求头、认证信息、超时设置等高级配置</li><li>满足企业级API集成需求</li></ul><h3 id="国际化支持"><a href="#国际化支持" class="headerlink" title="国际化支持"></a>国际化支持</h3><ul><li>完整的中英文国际化实现</li><li>提升产品国际化水平</li></ul><hr><h2 id="技术亮点"><a href="#技术亮点" class="headerlink" title="技术亮点"></a>技术亮点</h2><ol><li><strong>类型安全开发</strong>：采用TypeScript进行类型安全开发，确保代码质量</li><li><strong>动态表单生成</strong>：基于JSON Schema实现动态表单生成，提升用户配置体验</li><li><strong>状态管理优化</strong>：使用React Hook + Context模式进行状态管理，优化组件性能</li><li><strong>OpenAPI集成</strong>：实现OpenAPI规范自动解析，支持批量导入API工具</li><li><strong>可复用架构</strong>：设计可复用的工具集架构，为后续MCP工具集奠定基础</li></ol><hr><h2 id="技术实现细节"><a href="#技术实现细节" class="headerlink" title="技术实现细节"></a>技术实现细节</h2><h3 id="前端架构"><a href="#前端架构" class="headerlink" title="前端架构"></a>前端架构</h3><ul><li>使用React + TypeScript构建现代化前端界面</li><li>基于Chakra UI实现响应式设计，支持PC和移动端</li><li>采用Context + useContextSelector优化组件渲染性能</li><li>实现动态表单系统，支持JSON Schema驱动的配置界面</li></ul><h3 id="后端架构"><a href="#后端架构" class="headerlink" title="后端架构"></a>后端架构</h3><ul><li>设计RESTful API接口，支持工具集的完整CRUD操作</li><li>实现OpenAPI规范解析器，自动生成HTTP工具配置</li><li>集成MongoDB进行数据持久化，支持事务操作</li><li>添加完整的权限控制和团队隔离机制</li></ul><h3 id="核心功能模块"><a href="#核心功能模块" class="headerlink" title="核心功能模块"></a>核心功能模块</h3><ul><li>HTTP工具集创建与管理：<code>/api/core/app/httpTools/create</code></li><li>OpenAPI规范解析与工具生成</li><li>动态请求头和认证配置</li><li>工具执行引擎与结果处理</li></ul><h3 id="代码质量保障"><a href="#代码质量保障" class="headerlink" title="代码质量保障"></a>代码质量保障</h3><ul><li>完整的TypeScript类型定义</li><li>统一的错误处理机制</li><li>国际化支持（i18n）</li><li>组件化和可复用设计</li></ul><hr><h2 id="项目影响"><a href="#项目影响" class="headerlink" title="项目影响"></a>项目影响</h2><h3 id="管理效率提升"><a href="#管理效率提升" class="headerlink" title="管理效率提升"></a>管理效率提升</h3><ul><li>提升了HTTP工具的管理效率</li><li>用户可在单个工具集中管理多个相关API</li></ul><h3 id="系统可扩展性"><a href="#系统可扩展性" class="headerlink" title="系统可扩展性"></a>系统可扩展性</h3><ul><li>增强了系统的可扩展性</li><li>为企业级API集成提供了更强大的支持</li></ul><h3 id="用户体验优化"><a href="#用户体验优化" class="headerlink" title="用户体验优化"></a>用户体验优化</h3><ul><li>优化了用户体验</li><li>简化了HTTP工具的创建和配置流程</li></ul><hr><h2 id="量化成果"><a href="#量化成果" class="headerlink" title="量化成果"></a>量化成果</h2><ul><li><strong>代码贡献</strong>：新增约2000+行高质量TypeScript代码</li><li><strong>功能覆盖</strong>：支持GET&#x2F;POST&#x2F;PUT&#x2F;DELETE等全HTTP方法</li><li><strong>配置灵活性</strong>：支持自定义请求头、认证、超时等10+配置项</li><li><strong>用户体验</strong>：将HTTP工具创建流程从多步骤简化为一站式配置</li></ul><hr><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p><strong>前端技术</strong>：TypeScript, React, Chakra UI, JSON Schema</p><p><strong>后端技术</strong>：Node.js, MongoDB, RESTful API</p><p><strong>开发工具</strong>：OpenAPI, 国际化, 组件化设计, 性能优化</p><p>这个项目展现了在全栈开发、架构设计、用户体验优化等多个方面的能力，特别是在开源项目中的贡献和对复杂业务场景的技术解决方案设计能力。</p><hr><h2 id="简历重点"><a href="#简历重点" class="headerlink" title="简历重点"></a>简历重点</h2><ul><li>HTTP工具集的增删改查基本方法<br>  设计restful api</li><li>openapi自动解析<br>  外部包 + 手动处理</li><li>自定义请求头和鉴权配置<br>  前端动态配置 + 后端存储 + 运行使用</li><li>前端还原figma设计稿</li><li>工具执行<br>  封装HTTP请求类</li><li>节点相关<br>  存储节点: 保存ui等信息, 便于渲染<br>  运行时节点: 只保留运行时的相关配置, 加快运行速度</li><li>节点业务逻辑(太复杂了)<br>  工具调用请求<br>  ↓<br>  dispatchRunTools (Agent节点)<br>  ↓<br>  LLM工具选择 + 参数解析<br>  ↓<br>  runToolCall (工具调用循环)<br>  ↓<br>  dispatchRunTool (具体工具执行)<br>  ↓<br>  工具类型分发 (System&#x2F;HTTP&#x2F;MCP)<br>  ↓<br>  结果处理 + 格式化<br>  ↓<br>  返回给Agent继续对话</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 实习经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastGPT实习：生产者-消费者模式实现企微流式响应</title>
      <link href="/2025/09/21/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%BC%81%E5%BE%AE%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94/"/>
      <url>/2025/09/21/FastGPT%E5%AE%9E%E4%B9%A0%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%BC%81%E5%BE%AE%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="从企业微信流式响应中学习生产者-消费者模式"><a href="#从企业微信流式响应中学习生产者-消费者模式" class="headerlink" title="从企业微信流式响应中学习生产者-消费者模式"></a>从企业微信流式响应中学习生产者-消费者模式</h1><p>需求分析：在 FastGPT 平台，将工作流的发布渠道与企业微信智能机器人对接</p><p>实现企业微信回调 FastGPT 的地址，FastGPT 将工作流处理好的 AI 回复返回给企微</p><p>实现企微智能机器人能够使用 FastGPT 平台的功能</p><hr><h2 id="企业微信对接文档-流式响应的架构"><a href="#企业微信对接文档-流式响应的架构" class="headerlink" title="企业微信对接文档-流式响应的架构"></a>企业微信对接文档-流式响应的架构</h2><p>企微会给回调 URL(即自己配置的后台程序)发送两种类型的请求</p><p>第一种是消息推送, 只会在第一次向后台程序发送请求时发送</p><p>第二种是轮询请求。即当企微接收到消息推送请求的响应后,开始发送轮询请求</p><p>具体文档可参考 <a href="https://developer.work.weixin.qq.com/document/path/100719">企业微信智能机器人文档</a></p><hr><h2 id="实现难点"><a href="#实现难点" class="headerlink" title="实现难点"></a>实现难点</h2><ol><li>为什么企业微信要发送轮询请求？消息推送请求和轮询请求的本质区别是什么？需要为两种请求写不一样的逻辑处理吗？</li><li>等待 AI 输出全部结果，再返回给企微，耗时太长，如何优化</li><li>HTTP 请求是无状态的, 后台程序每收到一次请求, 都不知道上一次请求响应了什么数据, 从而无法实现回复内容的追加</li><li>如果每接收一次请求, 就调用一次 AI 输出回答. 由于轮询的频率很快, 一次 AI 回答还没输出完, 就要又一次调用 AI 输出. 最后会产生“轮询次数 + 1”倍的 AI 回复</li><li>AI 回复结束, 就要停止企微的轮询请求(发送特定格式的数据包), 那么要给后台程序怎样的逻辑, 才能实现 AI 回复结束,就向企微发送”结束数据包”</li></ol><hr><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="方案一-一次请求对应一次完整回复"><a href="#方案一-一次请求对应一次完整回复" class="headerlink" title="方案一 一次请求对应一次完整回复"></a>方案一 一次请求对应一次完整回复</h3><p>企微发送一个请求，程序接收后，会调用 AI 输出回答，AI 回复结束后，返回给企微一个响应</p><h4 id="具体效果"><a href="#具体效果" class="headerlink" title="具体效果"></a>具体效果</h4><p>首先是等待 AI 输出完成的时间太长，用户体验不佳</p><p>其次每接收一次请求都调用一次 AI，因为有轮询请求，所以会产生非常多次 AI 回复</p><p>而企微会渲染最后一次接收的回复，那么前面的回复就浪费了性能</p><h3 id="方案二-流式回复"><a href="#方案二-流式回复" class="headerlink" title="方案二 流式回复"></a>方案二 流式回复</h3><p>使用异步迭代器，异步流式处理数据</p><ol><li>异步可迭代对象生成一个异步迭代器</li><li>异步迭代器自动调用 next()方法, 通过异步请求获取 ai 回复</li><li>判断迭代结果的 done 值是否为 true, 是则停止循环, 不是则重复第二步请求数据</li></ol><h4 id="具体效果-1"><a href="#具体效果-1" class="headerlink" title="具体效果"></a>具体效果</h4><p>通过异步获取数据, 使得 ai 回复数据传输到 FastGPT 平台是”实时”的, 解决了等待 ai 回复时间过久的问题</p><p>但是没有解决从 FastGPT 到企微, 一段一段的流式数据如何传输的问题</p><h3 id="方案-n-生产者-消费者设计模式"><a href="#方案-n-生产者-消费者设计模式" class="headerlink" title="方案 n 生产者 - 消费者设计模式"></a>方案 n 生产者 - 消费者设计模式</h3><p>生产者: 程序接收消息推送请求，负责将数据写入 redis</p><p>消费者: 程序接受轮询请求，负责从 redis 中取出数据</p><p>缓存层: redis</p><h4 id="具体效果-2"><a href="#具体效果-2" class="headerlink" title="具体效果"></a>具体效果</h4><p>用户向企微发送消息后, 企微会先向后台程序发送一次消息推送请求</p><p>后台程序接收推送并按照企微的要求响应，响应后程序不会立即停止</p><p>而是等待 AI 不断输出新的回复，并不断将新的回复写入 redis 当中</p><p>写入是以追加的形式写入，即每次携带的回复都是上一次携带回复数据的追加值(累加值)</p><p>直到 AI 输出完成，这一次响应才彻底结束</p><p>在企微这边，当接收到消息推送请求的响应后, 就开始发送轮询请求(发送时间间隔 &lt; 1s )</p><p>后台程序接收到一次轮询请求后，就从 redis 中取出数据,并返回给企微</p><p>由于程序会不断将 AI 的输出结果存入 redis，而 AI 的输出是流式的</p><p>所以每一次从 redis 中取出的数据是越来越多，逐渐完善的</p><p>从而实现返回给企微的数据是类似 AI 输出的流式效果</p><p>当后台程序发现 AI 已经回复完成后，会在文本末尾加上“[DONE]”，表示回复结束</p><p>此时程序检测到文本末尾的内容，就会向企微发送一个特殊格式的数据包，标志着回复结束</p><p>企微接收到结束数据包，便不再发送请求，轮询结束，一次 AI 对话完成</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><h4 id="后续优化方向"><a href="#后续优化方向" class="headerlink" title="后续优化方向"></a>后续优化方向</h4><p>缓存层使用消息队列，能更加方便控制缓存的粒度</p><p>实时通信方式采用 WebSocket，而不是 HTTP 轮询</p><p>HTTP 轮询每一次请求都要重新连接，开销大，而 WebSocket 只需一次连接</p><p>HTTP 轮询的服务端只能被动回复客户端，而 WebSocket 的服务端能够主动给通信</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机（SVM）初见</title>
      <link href="/2025/05/09/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%EF%BC%88SVM%EF%BC%89%E5%88%9D%E8%A7%81/"/>
      <url>/2025/05/09/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%EF%BC%88SVM%EF%BC%89%E5%88%9D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h1 id="SVM-学习"><a href="#SVM-学习" class="headerlink" title="SVM 学习"></a>SVM 学习</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>SVM分为：<ul><li><strong>SVC</strong>（分类任务）</li><li><strong>SVR</strong>（回归任务），股票分析主要用SVR</li></ul></li><li><strong>超平面</strong>：k-1维的最佳分类标准</li><li><strong>支持向量</strong>：离超平面最近的点</li><li><strong>支持向量机</strong>：找到支持向量，构建超平面</li><li><strong>核函数</strong>：将低维空间映射到高维空间，使得数据线性可分</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>以 <code>get_train_model</code> 函数为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_train_model</span>(<span class="params">dataset</span>):</span><br><span class="line">    <span class="comment"># 设置训练阶树</span></span><br><span class="line">    DEGREE_POLY = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进行因子筛选</span></span><br><span class="line">    selected_factors = get_ic_with_sharpe(dataset)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进行训练集和测试集提取</span></span><br><span class="line">    X = dataset[selected_factors].values</span><br><span class="line">    y = dataset[<span class="string">&#x27;sharpe&#x27;</span>].values</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># SVM 的 Pipeline</span></span><br><span class="line">    svm_pipe = Pipeline([</span><br><span class="line">        (<span class="string">&#x27;sc&#x27;</span>, StandardScaler()), </span><br><span class="line">        (<span class="string">&#x27;poly&#x27;</span>, PolynomialFeatures(degree=DEGREE_POLY)),</span><br><span class="line">        (<span class="string">&#x27;svm&#x27;</span>, SVR())</span><br><span class="line">    ])  <span class="comment"># 添加多项式特征</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置 SVM 的参数的取值范围</span></span><br><span class="line">    svm_params = &#123;</span><br><span class="line">        <span class="string">&#x27;svm__C&#x27;</span>: np.logspace(-<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>),</span><br><span class="line">        <span class="string">&#x27;svm__degree&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        <span class="string">&#x27;svm__kernel&#x27;</span>: [<span class="string">&#x27;poly&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置 SVM 的 GridSearchCV 实例</span></span><br><span class="line">    svm_gs = GridSearchCV(svm_pipe, svm_params, scoring=<span class="string">&#x27;r2&#x27;</span>, n_jobs=-<span class="number">1</span>, cv=<span class="built_in">min</span>(<span class="number">5</span>, <span class="built_in">len</span>(X_train) - <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练 SVM 模型</span></span><br><span class="line">    svm_gs.fit(X_train, y_train)</span><br><span class="line">    best_svm_pipe = svm_gs.best_estimator_</span><br><span class="line">    best_svm_pipe.fit(X_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(best_svm_pipe)</span><br><span class="line">    <span class="keyword">return</span> best_svm_pipe</span><br></pre></td></tr></table></figure><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><h3 id="1-数据读取和预处理"><a href="#1-数据读取和预处理" class="headerlink" title="1. 数据读取和预处理"></a>1. 数据读取和预处理</h3><ol><li>设置阶数（因为用的核函数是多项式核）</li><li>筛选因子</li><li>数据集划分，分为训练集和测试集</li></ol><h3 id="2-模型构建（使用-Pipeline-）"><a href="#2-模型构建（使用-Pipeline-）" class="headerlink" title="2. 模型构建（使用 Pipeline ）"></a>2. 模型构建（使用 Pipeline ）</h3><ol><li>标准化：统一数据尺度，提升模型性能，避免某些特征因数值范围过大而对模型产生不成比例的影响</li><li>多项式特征转换：数据升维</li><li>SVM回归器（SVR）</li></ol><h3 id="3-参数优化"><a href="#3-参数优化" class="headerlink" title="3. 参数优化"></a>3. 参数优化</h3><ol><li>参数网格搜索：排列组合每种参数组合<ul><li>C值：惩罚项，越大，对错误分类的惩罚越重，模型会尽量正确分类所有训练样本，可能导致过拟合</li><li>多项式阶数：阶数越高，模型越复杂，越容易过拟合</li><li>核函数：将数据映射到更高维空间，使线性不可分的问题变得线性可分</li></ul></li><li>交叉验证：评估每组参数性能，可防止过拟合，（做法：将训练集分成k份···）</li></ol><h3 id="4-训练模型"><a href="#4-训练模型" class="headerlink" title="4. 训练模型"></a>4. 训练模型</h3><p>使用最佳参数训练，返回训练最佳模型</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人月神话》读书笔记</title>
      <link href="/2025/04/17/%E3%80%8A%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/04/17/%E3%80%8A%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="《人月神话》读书笔记"><a href="#《人月神话》读书笔记" class="headerlink" title="《人月神话》读书笔记"></a>《人月神话》读书笔记</h1><p>2025.4.13 - 2025.4.17，笔者拜读了软件工程领域的名作《人月神话》，在此写下读书笔记与心得。</p><hr><h2 id="1-书籍介绍"><a href="#1-书籍介绍" class="headerlink" title="1. 书籍介绍"></a>1. 书籍介绍</h2><p>《人月神话》的行文以比喻见长，将软件工程中的各种问题以比喻的形式呈现</p><p>同时，本书表面上是讲软件工程，真正的内核是软件工程背后的社会学原理</p><p>遗憾的是，笔者才学疏浅，无法全部理解书中的各种概念，加之年代久远和翻译的误差，很多说法与如今有所出入</p><p>比如说系统设计与开发，在书中应该是指的是软件项目的架构的设计与实现</p><p>而在如今的语境中，指的是操作系统的设计与开发</p><p>尽管有所偏差，但笔者仍然想写下对书中经典比喻的分析</p><hr><h2 id="2-内核分析"><a href="#2-内核分析" class="headerlink" title="2. 内核分析"></a>2. 内核分析</h2><ul><li><p>焦油坑：在大型的软件开发中，实际进度会被各种问题耽搁<br>这些问题可以分为项目本身的代码问题和项目外的管理问题<br>从项目本身来看，如果一个项目前期的技术选型，代码规范，开发流程等没有事前安排好<br>那么随着项目的开发，这些问题会逐渐暴露，最终成为拖延进度的焦油坑；<br>从项目外来看，一个开发团队的组织与管理也会影响到项目的进度，一个好的团队可以参考后面的“外科手术队伍”这个比喻。<br>在笔者目前的认知中，最广为人知的焦油坑就是Windows操作系统。win系统从面世至今，经历了大大小小无数次内核改动。<br>可以说对于微软系统维护人员来说，Windows无疑是一座屎山，也是整个公司的焦油坑</p></li><li><p>人月神话：人月（Man-Month）指的是一名程序员一个月全职的工作量<br>而人月神话则是说在项目开发中不能简单的用人数换取时间进度，因而将这个说法称为人月神话<br>这里，笔者想讨论为什么不能用“人”来换“月”。<br>在一个软件项目中，如果一个项目的进度落后于规划，项目负责人想的第一件事很可能是增加人手<br>但软件行业不同于其它行业，增加的新人需要花时间熟悉项目的代码和开发流程<br>需要老成员来指导培训，甚至可能要处理新人开发不规范带来的问题。这样一来，项目的进度不但没有加快，反而被拖慢了。<br>但是在现实中，项目的进度遇到问题，负责人要么无休止的招新人，要么让老成员陷入加班的无底洞<br>这无疑是现代软件工程的可悲之处</p></li><li><p>外科手术队伍：不同于扁平化的团队模式，外科手术队伍指团队有一个核心开发（书中称之为首席程序员），也可以理解为CTO<br>整个团队的人员配置都是围绕这个核心开发展开的，比如要为核心开发配备一个副手，几个文员等等，再往下的就是普通程序员<br>这样的人员配置可能会遇到一些问题，这将在下面的“贵族专制”中提到，在现代公司的软件开发团队中，似乎与书中的外科手术队伍有所不同<br>这里由于笔者经验不足，无法获得更高层面的认知，就将此话题按下不表<br>不过在小型初创团队中，扁平化的管理方案似乎更能够提高效率</p></li><li><p>贵族专制和民主政治：贵族专制指的就是在外科手术团队的配置下，可能整个项目的走向都被首席程序员所决定<br>没有充分发挥下面普通程序员的主观能动性，下面的人也很难为团队建言献策<br>在这种情况下，民主政治的必要性就体现了出来，它使得所有人都能为项目提供建议，改善方向<br>但是在现代公司体系下，一个互联网公司&#x2F;一个软件开发团队，究竟能发挥多少民主政治，这要打一个大大的问好了</p></li><li><p>巴比伦塔的失败：在神话故事中，神让人们语言不通，通天塔的建造就此失败<br>在软件开发中，巴比伦塔的失败指的是团队成员之间的沟通不畅<br>那如何提高沟通次数效率呢？频繁的开会未必是个好主意<br>更需要的或许是精简团队人员，让整个团队保持同频</p></li><li><p>银弹：银弹（Silver Bullet）是由国外的人狼民间传说翻译而来<br>在故事中，人狼是个能从熟悉的面孔变成可怕怪物的东西，为了对付人狼，要寻找能消灭它们的银弹<br>银弹的本质就是解决某一个问题的方法，在中文语境下，可以理解为“灵丹妙药”、“尚方宝剑”或是“万精油”，但是不能等同<br>任何一个软件项目中几乎都存在人狼，比如对开发人员的技术高估，对项目的复杂度低估，预算的不充足等等<br>在这种情况下，开发人员迫切的渴求银弹，能解决这些问题，但是现实就是“没有银弹”</p></li><li><p>没有银弹：在书中，作者断言软件行业至少十年内不可能出现一种技术或是方法能大幅提升生产效率，简称“没有银弹”<br>这一说法首先要从软件的本质说起，首先软件本身就存在复杂度，可以分为本质复杂度和附加复杂度<br>本质复杂度指的是把现实世界的事物抽象成软件、编程语言的复杂程度<br>附加复杂度是指方法、工具和编程语言的落后等等带来的复杂度<br>从软件工程发展至今，从汇编，到c语言，再到面对对象和各种框架<br>人们用诸如oop、设计模式、敏捷开发等方法来降低复杂度<br>但究其根本，降低的都是附件复杂度，软件的本质复杂度始终没有改变，银弹始终没有找到<br>显然现代软件工程面临的问题是如何找到降低本质复杂度的方法<br>但最有可能的结果是，世界上根本不存在这样的方法，现实本身就是没有银弹</p></li></ul><hr><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>软件工程背后的社会学原理着实丰富，以目前笔者的经历与见识，可以说是管中窥豹</p><p>希望未来的某一天，当笔者能真正在一个软件项目团队独当一面时，能回想起人月神话中的道理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go爬虫学习</title>
      <link href="/2025/04/12/go%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/04/12/go%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="golang爬虫学习"><a href="#golang爬虫学习" class="headerlink" title="golang爬虫学习"></a>golang爬虫学习</h1><p>目的是学习一下爬虫的流程，顺便熟悉一下go的语法和使用</p><p>代码仓库见<a href="https://github.com/fishwww-ww/go-spider-mundo">我的github仓库</a></p><hr><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>本项目爬取的是<a href="https://mundo.trancecho.top/">mundo</a>中的组队信息，从而快速了解组队的概况，以便进一步筛选适合且人数未满的队伍</p><p>使用的工具：</p><ul><li>golang原生http库等网络请求、解析相关的库</li><li>gorm</li><li>docker</li></ul><hr><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><h3 id="1-分析网页"><a href="#1-分析网页" class="headerlink" title="1. 分析网页"></a>1. 分析网页</h3><p>打开<a href="https://mundo.trancecho.top/teamup">mundo组队</a>页面,F12打开开发者工具，找到网络栏</p><p>在document类型的请求中找到名为teamup的请求,查看它的响应,</p><p>发现里面没有数据,说明这些信息是通过api请求得到的,无法在DOM中获取</p><p>再筛选xhr类型,找到 allteam?service&#x3D;mundo ,正是所需要的响应</p><p>接下来通过伪造api请求,来获取它的响应,从而实现数据爬取</p><h3 id="2-实现请求"><a href="#2-实现请求" class="headerlink" title="2. 实现请求"></a>2. 实现请求</h3><p>将响应的json转换为go的结构体<br>可以直接复制json数据,交给ai处理,也可以用爬虫工具处理<br>得到响应结构体</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="type">int</span>    <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">    Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">    Data    Data   <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用go的http库,创建一个客户端,并将方法和url填入,构造一个请求</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://qgdoywhgtdnh.sealosbja.site/timerme/api/allteam?service=mundo&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>填入一些请求头,大型网站都有反爬机制,请求头越详细越好,这里只填入部分信息</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">req.Header.Set(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36 Edg/135.0.0.0&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json, text/plain, */*&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip, deflate, br, zstd&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行请求,并获取响应,别忘了最后关闭请求</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure><p>读取响应,并反序列化,便于后期操作数据</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">err = json.Unmarshal(body, &amp;response)</span><br></pre></td></tr></table></figure><h3 id="3-存入数据库"><a href="#3-存入数据库" class="headerlink" title="3. 存入数据库"></a>3. 存入数据库</h3><p>我是在docker中下的mysql,启动后新建一个schema,这个schema要和代码中的DBNAME对应上</p><p>直接用gorm框架来连接mysql</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DB, err = gorm.Open(mysql.Open(path), &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure><p>然后用AutoMigrate方法自动建表</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = DB.AutoMigrate(&amp;Content&#123;&#125;)</span><br></pre></td></tr></table></figure><p>最后回到处理响应的部分,将数据插入数据库中</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result := DB.Create(&amp;response.Data.Team.Content)</span><br></pre></td></tr></table></figure><hr><h2 id="项目收获"><a href="#项目收获" class="headerlink" title="项目收获"></a>项目收获</h2><ul><li>学会了分析网页和实现爬虫程序的流程</li><li>熟悉了go,docker和数据库连接,把请求,响应,解析,存储等流程串联起来</li></ul><h2 id="后续学习"><a href="#后续学习" class="headerlink" title="后续学习"></a>后续学习</h2><ul><li>学习go的并发编程,提高爬虫效率</li><li>学习docker的目录挂载机制,如何将数据挂载在宿主机中,实现数据的持久化</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>myFirstBlog</title>
      <link href="/2024/06/11/myFirstBlog/"/>
      <url>/2024/06/11/myFirstBlog/</url>
      
        <content type="html"><![CDATA[<h1 id="标题一"><a href="#标题一" class="headerlink" title="标题一"></a>标题一</h1><p>内容一二三四五<br><a href="https://www.baidu.com/">百度</a></p><hr><h2 id="标题二"><a href="#标题二" class="headerlink" title="标题二"></a>标题二</h2><p><a href="http://www.bing.com/">www.bing.com</a></p><hr><h3 id="标题三"><a href="#标题三" class="headerlink" title="标题三"></a>标题三</h3><p>markdown语法</p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
